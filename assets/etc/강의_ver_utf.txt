==========================================================================================

	자바의 기본개념 및 설치


==========================================================================================

#1 자바란

사람이 알아볼 수 있도록 원본소스를 텍스트화한 정보를
컴퓨터가 알아보도록 번역한다. 이것을 이진파일이라고 한다.

이때 번역하는 과정을 다시 말해 컴파일러라고 한다.

원본소스(source)


  Text file     -------(번역)--------> 이진파일(디지털언어)
                    (=컴파일러)


7

1) JavaSE(Standard Edition)

가장 먼저 알아야하는 과정, 반드시 선행되어야하는 기술.
이 기술을 알아두면 응용프로그램을 메이킹할 수 있다.


*응용프로그램과 웹프로그램으로 나뉨

응용프로그램 : 한대의 PC에서 사용되는 프로그램
웹프로그램 : 서버를 통해서 다수의 사용자가 사용할 수 있는 프로그램


JavaSE 에서 파생되는 두가지의 스킬이 존재함.

i) JavaEE(Enterprise)

: 자바가 할 수 있는 모든 환경을 지원한다.(ex.jsp, android etc,.)

*추후 JavaEE로 순서를 밟게된다.

ii) JavaME(Micro)

: 하드웨어적 지원 (ex. 스마트폰 이전의 모바일)


JDK(Java Developement Kit) ver.8

:컴파일러의 이름

JRE(Java Runtime Environment) ver.8

:JDK를 실행시키기 위한 필요도구(JDK설치시 자동인스톨)


자바를 공부하기에 앞서 컴퓨터의 구조 및 전자계산학개론을 선행학습해야한다.
(정보처리기사 안에 포함되어있는 내용임 ex.CPU, RAM, Mainboard etc,.)
그리고 프로그래밍언어를 학습하고 이후 알고리즘(자료구조)를 공부하도록한다.

*알고리즘사이트(정보 올림피아드)


-
path 설정 어디서든 실행프로그램을 실행할 수 있는 편리성을 제공한다.
자바의 path 설정을 해보자.

제어판 - 시스템보안설정 - 시스템 - 고급시스템 설정 - 환경변수

path 란에 세미콜론을 붙여넣고 디렉토리를 붙여넣는다.
*새로만들기  JAVA_HOME 을 만들어서 bin 이전 폴더를 만들어놓고
path에 %JAVA_HOME%으로 설정하면 더 세련됨

습관을 가질 것

1. ( ) <- method

   ex. println(); "println메소드" 라고 읽어라

2. 코드 위에 주석처리할 것.

3. 가독성을 높이기 위한 줄의 처리를 똑바로 할 것(들여쓰기)



" + " 는 숫자에서는 더하기 기능을 보여주지만 
문자열이나 모르는 것에 대해서는 연결하는 기능

다시 말해서,
100 + 5 에 대해서는 105의 결과값을 보여준다.
하지만 "100" + 5 에서는 단순히 100과 5를 연결함.




Day - 02



println 과 print

ln은 line 의 약자로 자동줄바꾸기의 기능을 가지고 있으며
print는 줄바꿈의 기능은 미포함한 명령어.


print 명령어를 사용하여 문자열 내에 역슬러쉬 \n 을 포함시키면 줄바꾸기를 할 수 있다.
역슬러쉬(\)는 단독으로 사용되면 escape(탈출) 즉 부정의 기능을 갖는다. 수학의 not 의미

문자를 잘 파악하여 사용하면 유용하게 쓰일 수 있을 듯 하다.

예를들어 문자를 출력하기 위해선 " " 내에 문자를 입력하게되고 " " 내에 문자만
화면에 출력이 되는데 " " 따옴표까지 확인하기 위해서 그 앞에 역슬러쉬를 붙여주면 된다.

ex)  "안녕하세요" 자체를 보고싶다면,   "\"안녕하세요\"" 라고 쓰면된다.

==========================================================================================

	데이터 타입 변수


==========================================================================================

1. Variable(변수)

(1) 임시 기억(저장) 장소(메모리=RAM)

상수는 두가지 의미를 가진다.
그러니 영어로 기억해두면 편함.

상수(literal)
 - 변하지 않는 고정된 수
 - 변하는 수


(2) 반드시 선언을 해야 한다.

	선언방법( 양식에 맞춰 용도와 크기를 알려줘야한다. 아래와 같음)
	DataType 변수명;

(3) 반드시 초기화를 해야 한다.(변수 선언 후에 처음 넣는것을 초기화)
(4) 반드시 선언된 블럭 안에서만 사용 가능하다(유효범위(=지역변수)라고 한다. {중괄호 열고 닫고})
	Stack 에 대해서 나중에 알아보도록할 것. 지역범위에 대한 것임



*int = ㅁ 

equal(=)은 수학적의미인 '같다'가 아닌 컴퓨터언어에서 우측의 변수를 좌측에 저장한다는 의미




2. DataType

(1) 저장되는 내용에 따라서 2가지로 나뉜다.

	1) 기본형(내장형(builtin), 비객체형, 클래스가 아닌 애들)

		- 용도와 크기

				*bit(2진수)는 byte를 이루는 최소단위
				 -8bit = 1byte
				 -1byte = 8bit = 2^8 = 256개의 숫자를 저장(-128~127까지 0포함)

			정수형
				byte	1byte 8bit
				short	2byte 16bit
				int	4byte 32bit
				long	8byte 64bit

			실수형

				float	4byte
				double	8byte



			문자형 (문자=1개 홑따옴표(' ') 문자열=1개 이상 쌍따옴표( " " ))
				
				*Note
				 문자열은 몇개의 문자가 저장되는지 가늠할 수 없으므로 기본형에서는 저장매체가없음
				 char는 왜 한글자만 저장가능하도록 1byte를 할당하지 2byte를 할당하였는가?

				 -ASCII(아스키코드)코드에 답이있다.
				  아스키코드는 영어만을 포함한다. 128개의 언어 2^7이며 여유공간으로 2^8의 공간을 할당했다.
				  하지만 국제적문제로 영어권을 제외한 다른 나라의 언어를 수용하기 위해 1byte를 추가할당했다.
				  그 코드가 바로 unicode 즉 전세계적인 언어를 수용할 수 있는 코드가 된다. 물론 아스키코드도 유니코드에 포함된다.


				char	2byte

			논리형 (bit형이며 참인지 거짓인지만 판별한다.)

				boolean
					true, false


	2) 객체형 : 클래스로 만든 데이터 타입



3. Operator

(1) 종류
	1) 산술연산자 (산술값이 나옴)


		* / % + -	-> 이항연산자


		++증가	-> 단항연산자
		--감소	-> 단항연산자

	2) 비교연산자 ( true, false 의 예 아니오만 나옴)


		> < >= <= == (같다) != (같지않다)


	3) 논리연산자
		&&(and연산자)  ||(or연산자)  !(not연산자 또는 토글연산자toggle:하나의 키를 가지고 번갈아가면서하는 것)
										ㄴ게임에서 많이 활용
										ㄴ키보드의 넘버락도 마찬가지

	(진리표)a		b	a&&b	a||b	!a	a^b(XOR)
		---------------------------------------------
		T	T	T	T	F	F
		T	F	F	T	F	T
		F	T	F	T	T	T
		F	F	F	F	T	F


	4) 대입연산자

		=  +=  -=  *=  /=  %= .... (복합대입연산자)

		복합대입연산자는 이미 캐스팅연산이 포함되어있다.


	5) 비트(bit)연산자

		&(and)  |(or)  ^(XOR)  >>(Right Shift)  >>>(Right Shift)  <<(Left Shift)  ~(보수)


	6) 캐스팅(casting) 연산자 : 강제 형변환 연산자
		
		쓰는 방법 : (DataType)변수명

		1) 명시적 캐스팅 : 내가 직접 눈에 보이게 어떤 형태의 변환을 하도록 하는 것
		2) 묵시적 캐스팅 : 시스템이 알아서 강제 변환을 하는 것(가능한 것에 대해서 명령어를 삽입안해도)


	7) 삼항 연산자(조건 연산자)

		변수 = 조건식 ? 참 : 거짓 (조건이 참이면 참을 실행하고 거짓이면 거짓을 실행, 조건식이 짧을때 사용)






XOR

11001011	00100111
11101100    -> ^11101100
--------	--------
00100111	11001011


*NOTE
 -연산순서가 가장 중요한데 수많은 연산순서를 다 기억하기 힘듦 그러므로 괄호를 활용하여 순서를 만들것!

 -논리연산자가 비트연산자보다 강점으로 가지는 점이 있다.
  그것이 바로 단락회로 : 쓸데없는 연산을 끊어내겠다.
   ㄴ앞의 논리값이 이미 거짓으로 나왔을 때 뒤의 논리값은 계산하지 않는다.



문제

1. 리터를 갤런으로 바꿔보자. double 

double litter = 5;
double gallon = ?;


2. 달의 중력은 지구 중력의 17% 내 몸무게는?

3. 번개가 얼마나 먼곳에서 발생했나? 번개치고 1000ft 7.25



Day-03



System.out.print 에서 out은 출력할때 쓰는 장치를 뜻한다.(모니터)

System.in.read 에서 in은 무언가를 입력하는 것

키보드를 통해 입력 버퍼에 임시저장된다. (아직은 프로그램에 전달되지 않았지만 화면에는 커서 위에 확인된다.)
엔터를 누르면 프로그램에 입력이 되고 결과값을 도출할 수 있음.


처음 a를 입력했다면 입력 버퍼 메모리자리에 a가 등록되고 결과를 송출하기 위해 엔터를 누르면
엔터키가 a 다음 자리에 위치하게 된다. 그래서 다음 키가 입력이 안되므로 강제로 스킵해준다.

System.in.skip(); 소괄호 안에 문자 byte 만큼 입력해준다. (최소단위 2byte)


4. Control Statement(제어문) 	*제어문의 조건식은 method가 아니다 method라고 부르지말고 이름을 불러라.
				*제어문을 제외한 나머지는 모두 method임


(1) Condition Statement
	
	1) if
		- if(조건식){
			문장;		// 괄호 안의 조건식이 참이라면 문장을 실행하라.
			문장;		  (괄호안 조건식이 참이라면이라는 전제는 모든 조건식에 동일하다)
			문장;
			문장;
			...
  		  }



------------------------------------------------------------------------------------------------------------



		- if(조건식){
			문장;
			문장;
			
		  }
		- else{			//if 조건식의 문장이 참이 아니면 else의 문장을 송출하라
			문장;
			문장;
			...
		  }


------------------------------------------------------------------------------------------------------------

		- if(조건식){
			문장;
			문장;
			
		  }
		- else if(조건식){			// 다중if문:다중의 조건식을 사용하고싶을때
			문장;				// 더이상 조건문을 달지않고 마무리할때는 그냥 else로 마무리
			...
		  }

		- else if(조건식){			
			문장;
			...
		  }

		- else{			
			문장;
			...
		  }




------------------------------------------------------------------------------------------------------------

		- Nested if (if문 내에 if문이 있는 경우로 중첩된 if문이라고 한다.)

			if(조건식){
				...
				if(조건식){
					...
				}
			}


	2) switch (case값이면 문장을 처리하라. 뭐보다 크냐 작냐의 범위를 계산할 수는 없음)

		switch(변수나 수식에 대한 결과값){
			case 값:
				문장;
				break;

			case 값:
				문장;		
				break;
			case 값:
				문장;
				break;			
			...

			[default:
				문장;] case값이 없으면 else와 마찬가지 기능으로 default를 사용. [대괄호] 생략가능
			}



(2) Loop Statement(반복문)


---------------------------	*Note     ----------------------------------------------------------------
				 1. 반복횟수를 주의하라.
				 2. 무한반복(루프)

					위의 사항을 방지할 수 있는 지킬점 3가지

					-초기화
					-조건식
					-카운터

----------------------------------------------------------------------------------------------------------


	1) while (*괄호안의 조건식이 참일동안 실행하라. 거짓이 될때까지.. 거짓이되면 끝남)

		- while(조건식){
			문장;
			...
		}

----------------------------------------------------------------------------------------------------------


	2) do while (*위의 while은 조건식이 맞지 않으면 실행자체가 안되지만 do while은 최소 실행은 한번 해봄)

		- do{
			문장;
			...
		  }while(조건식);



	3) for (*초기 조건 카운터가 모두 들어간 반복문으로 안정적인 코딩이 가능하다)

		for(초기화; 조건식; 카운터)
			문장;

		
		*NOTE

		 -초기화를 다른 곳에서 했다면 for문 내에서 빈공간으로 두어도 상관없다.

		초기화;
		for(  ; 조건식; 카운터){
			...
		}


		*NOTE

		-조건식을 다른 곳에서 하고 싶다면 다른 자리에 해도 상관없다. 자리만 비워둬라.


		초기화;
		for(  ;  ; 카운터){
			...
			조건식;
			...
		}


		*NOTE

		-카운터를 다른 곳에서 하고 싶다면 다른 자리에 해도 상관없다. 자리만 비워둬라.


		초기화;
		for(  ;  ; ){
			...
			조건식;
			...
			카운터;
		}



	4) 무한 반복(무한반복이 쓰여야할 때도 있다 ex.서버)
		
		while(true){
			...			// 끝내고 싶을 때는 if문같은 조건문을 달아준다.
		}


		for(;;){
			...			// 상동
		}




	5) 강제 종료(원하는 값을 찾았을 때 반복문을 강제 종료시키는 도구)

		*Note
		 - 아래의 명령어는 반드시 반복문 내에서 사용되야한다. (break는 제외 switch에서 사용됨)


		- continue 	: 일시종료(continue가 포함된 반복문의 처음으로 돌아간다)

		- break		: 완전종료


(3) 중첩 반복문




Day04~07



********************************************************************

Build 자동화 툴

1. ANT


********************************************************************






설정 준비=====================================================================================


*build.xml 작성

<project> 꺽쇠는 태그

끝이있어야한다. 끝은 </ > 루트태그이다. (최상위)

<target name=""> name 설정해줘야한다



<?xml version="1.0" encoding="euc-kr"?>

<project default="run">
	<target name="compile">
		<!-- 컴파일하라는 명령 -->
		<javac srcdir="./src" destdir="./bin" includeantruntime="false" />
	</target>
	
	<target name="run" depends="compile">
		<java classname="ClassTest1">
			<classpath>
				<pathelement path="./bin"></pathelement>
			</classpath>
		</java>
	</target>
	
</project>




변수추가




<?xml version="1.0" encoding="euc-kr"?>

<project default="run">
	<property name="main" value="ClassTest1"/>
	
	<target name="compile">
		<!-- 컴파일하라는 명령 -->
		<javac srcdir="./src" destdir="./bin" includeantruntime="false" />
	</target>
	
	<target name="run" depends="compile">
		<java classname="${main}">
			<classpath>
				<pathelement path="./bin" />
			</classpath>
		</java>
	</target>
	
</project>


===============================================================================================






-----------------------------------------------------------------------------------------------

Class Part.1


1. 묶음 - 변수
	- 메소드

2. 캡슐화단위(편의성, 보안성, 최소화(원자))

3. 설계도(추상적) - 인스턴스(Instance) : 메모리에서 실제 클래스가 사용할 수 있는 데이터공간

4. 데이터 타입




-----------------------------------------------------------------------------------------------

변수의 종류

1. 선언된 위치에 따라서

	1) 클래스 안에 선언되는냐 : 인스턴스 변수(멤버변수)
	
		- 클래스 안에 선언된 변수를 인스턴스 변수라고함
		- 변수를 선언하기 위해서 인스턴스를 해줘야하니까

	2) 메소드 안에 선언되느냐 : 변수(지역변수)


2. 저장되는 내용에 따라서

	1) 값 : 변수		(값만 저장가능)
	2) 주소 : 참조 변수	(주소만 저장가능)



-----------------------------------------------------------------------------------------------

메소드(method)

- 함수나 메소드는 같은 말이지만, 어디에도 속하지 않으면 함수라고 부르고 클래스 내에 속하면 메소드라고 칭하자.


1. 동작을 구현하는 역할

2. 메소드 만드는 방법

	반환형 이름(...){
		기능 정의
	}

3. 사용하는 법

	메소드명(...)					// "호출(call)한다" 라고 말함.


4. 호출 방식 
	(1) 인자(수)가 없는 방식 (MethodTest1) : Jump해서 가는 방식
	(2) 인자(수)가 있는 방식 (MethodTest1) : Jump해서 가는 방식
	(3) 반환값이 있는 방식 : 리턴하는 방식


5. return
	(1) 값을 반환한다 : 단, 값 1개만 반환 가능(ex: return num3; 만 가능 return num3, num1; 이렇게는 안된다.)
	(2) 메소드를 강제 종료( 끝괄호를 만나지않고 리턴을 만나면 리턴 밑의 문장은 실행하지 않는다)



==================================================================================================


6. 메소드의 오버로딩(Overloading)(*객체지향만이 가지는 특별한 문법) : 중복을 의미하고 정의 // 오버로딩은 메소드에서만 쓸수있다.

	(1) 다형성을 구현(같은 이름의 메소드를 여러개 만들 수 있다. 
		
		-> 여러개의 메소드 이름을 하나의 이름으로! 편하다, 하지만 어떤 것을 호출하는지 구분이 안됨)
		-> 하는 일이 달라야 한다. 인자값이 달라야한다는 것인 것과 같다. 매개변수가 다르다는 말과 동일.

	(2) 매개변수의 갯수, 순서, 형식 (위의 1번의 단점을 극복하기 위해 매개변수가 달라야한다.)




7. 생성자(constructor)(메소드의 일종이긴하나, 기존 메소드와는 하늘과 땅 차이)

	- 인스턴스를 만들어주는 메소드
	- 인스턴스를 생성할 때만 호출가능 (1회용)

	(1) 인스턴스를 생성해주는 기능(특화된 전용 기능)
	(2) 호출 시점 : 인스턴스를 생성할 때, 단 한번만 호출 가능
	(3) 초기화 전문 메소드
	(4) 작성 방법(한번 사용되면 끝이며, 반환될 필요가 없기 때문에 반환형이 없다)
		- 메소드명(...){
			  ...
		}
	(5) 반드시 매소드명은 클래스명과 동일하게 작성해야한다.
	(6) 모든 클래스는 반드시 기본생성자를 갖는다.(*기본생성자는 인자가 없는(내가만들지않은) 매개변수가 없는 생성자)
	(7) 단, 임의의 생성자를 만들게 되면 더 이상 기본생성자는 제공되지 않는다.(임의의 생성자= 인자가 있는(내가만든) 생성자)
	(8) 인스턴스 변수를 초기화해준다.








Garbage Collection(쓰레기: 메모리잡아놓고 안쓰는거)

JVM(JavaVirtualMachine)

개발자가 프로그램을 만들기 위해서는 운영체제(windows)의 도움이 필요하다.
운영체제가 프로그램의 개발이나 실행을 돕기 위해 사용하는 도구를 API 라고 한다.

JVM을 실행하기 위해서는 JRE가 실행되어야한다.
JRE가 실행되어 JVM를 구동하게되면 
운영체제의 도움을 받지 않고 가상머신의 메모리에 저장할 수있으며
다른 운영체제로의 이동 및 확장이 가능하다.

javac는 자바의 소스로 만들어 가상머신내에서 컴파일하고 class 라는 확장자명을 가지고 태어난다. exe가 아니다.
그리고 그것을 운영체제로 가져와서 실행하기 위해서 사용되는 것은 java다.

이진파일을 자바에서는 바이트 코드라고 부른다. (기계가 해석하는 언어)

쓰레기수거를 JVM이 해준다.


쓰레기청소를 부탁하는 메소드 g(c) (바로 당장 청소하지는 않는다.)


Garbage Collection
===================

	- finalize() : 메모리가 삭제되기 직전에 시스템이 호출하여 코드가 있는지 확인한다.
			내가 미처 다 작업하지 못한 내용을 담아 나중에 확인할 수 있도록 활용할 수 있다.
	(callback 메소드라고 한다. (사용자가 아닌, 시스템이 호출해서 사용한다.)








this
----

1. 참조변수(주소만을 저장하는 변수. 단지, 사용자가 만드는 변수가 아니다)

2. read only(읽기전용)

3. 현재 실행 중인 인스턴스의 주소를 저장
	- cpu 는 한번에 한가지 일만한다. 10만개의 주소를 저장하지만 실행되는 인스턴스는 1개임

4. this() : 현재 실행 중인 생성자를 호출하는 메소드(같은 클래스 내에서 자기들끼리 호출한다라는 의미)

-------------------------------------------------------------------------------------------------

번외편

※객체(object)지향(oriented)언어(programming)



 -Dos
	: 구조적(절차적) 프로그램방식, 1인체제(프로그래머가 대우받던 시절)





 -windows 
	
	: 다수, 팀프로젝트 체제
	: (다수의 인원이 다루기에)하나의 큰 프로그램을 나누기 좋고 분리할 수 있는 기능, 또는 일부분 이것을 객체라고한다.
		※단, 독립적 분리가능하고, 조립이 가능해야하며, 재사용이 가능해야한다.(정형화된 틀이어야한다)



★즉, 객체는 인스턴스와 같다고 보면된다.



객체라는 타이틀을 얻기 위해서는

①Inheritance(상속성)
②polymorphism(다형성)			// 이 세개를 모두 포함해야 완벽한 객체지향언어
③Encapsulation(캡슐에넣음)


(JAVA는 완벽한 객체지향언어, Javascript는 객체기반언어)


1. Inheritance(상속성) : 객체지향언어 중에 가장 화려함

 - 소스가 없이 실행파일만 있는 상태에서도 가져다 쓸 수 있음.
 - 복붙도 가능
 - 즉, 재사용이 가능하다.(비용절감, 시간절약)


2. Polymorphism(다형성) : 하나의 객체가 다양한 모양을 갖는다.

 - 하나의 이름으로 여러 작업을 수행할 수 있도록 한다.
 - 개발자에게 편의성을 제공하다.


3. Encapsulation(캡슐화) : 편의성, 보안, 최소단위, 추상적

 -








Day07~

이클립스(eclipse)

*사용하기 위한 2가지 개념

 - 프로젝트 환경을 만들어야한다.
 - 여러 개의 프로젝트를 하나로 묶어 관리할 수있는 work space를 생성하여 사용한다.



******************************************************************************************

Array(배열)


int arr1[] = {1, 2, 3};	// 어레이1 이라는 변수에 하나를 묶어 인스턴스 선언을 한다. 그 안에는 1, 2, 3이라는 변수가 있는 것.


arr1[0] = 10;		// 그리고 어레이1의 변수에 0이라는 방으로 가서 1의 정수를 10으로 바꿀때 이와 같이 초기화한다.


*1차원배열은 직접적이라 쉬움.


int [][]arr2 = {{1,2,3}, {4,5,6}};

arr2[0][1]=20;
arr2[1][2]=30;






불편하게 하나만 등록할 수 있던 변수 -> 배열을 이용하여 편의성을 확보하자.


1. 같은 이름으로 정의된 연속적인 공간

	int kor, eng, mat, rank;

	한줄로 붙여진 배열을 1차원배열(또는 선형배열)이라한다


	만일
	
	int kor, eng, mat, rank;
	int kor2, eng2, mat2, rank2;
	int kor3, eng3, mat3, rank3;

	이렇게 12개의 변수를 1차원 배열하면 3개로 나타낼 수 있다.
	*그림파일참고


2. 배열은 객체로 취급이 된다.(객체라는 것은 인스턴스와 직결된다)

	Stack & Heap(*그림파일참고)

	- 두 메모리는 같은 선상에 있는 것은 아니다.



	Stack : 임시적으로 저장하며 중요한 것을 저장하지말 것. 대부분 주소를 저장하는데 사용
		(강의 시간 예제에서 본 sungjuk과 같은 주소)

		stack은 먼저 입력된 데이터를 가장 아래 저장하여 데이터를 쌓는구조.
		꺼내쓸 때는 가장 위의 것 즉, 최근에 저장한 데이터를 사용하는 구조이다.
		이 구조를 LIFO 구조라고 한다. Left in first out
		(*그림파일참고)

	Heap : 장기간 오랫동안 저장이되며, 중요한 것을 저장하고 인스턴스가 저장된다.
		(강의 시간 예제에서 본 int[4]가 저장된다)


3. 배열로 할 수 있는 것

	(1) 검색기능 제작 가능
		
		1) 순차검색 : 속도에 대한 평가가 좋지는 않다 (n/2 데이터 개수에 따라 평균속도가 변동되므로)
		2) 이분검색 : 데이터가 정렬되어있어야한다. (왼쪽 오른쪽에 대한 구분이 필요하니까)

	(2) 정렬기능 제작 가능


		1) 버블정렬 : 서로 이웃하는 것끼리 비교하여 교체해나가는 방식
		2) 선택정렬 : 기준위치를 정하여 비교해 나가는 방식
		3) 삽입정렬

		===========
		Swap Algorithm(교환, 교체알고리즘)

			int a = 10, b = 5, c; 서로를 교환하여라.

			c = a;
			a = b;
			b = c;




버블정렬

6	3	7	5
3	6	7	5
3	6	7	5
3	6	5	7
---------------------------- 한번 반복에 필요한 횟수는 데이터의 -1, 가장 큰 값은 한번에 반복에 의해 맨 뒤로간다.
				(오름차순일 경우)

3	6	5	7
3	5	6	7
3	5	6	7
---------------------------- 

3	5	6	7
3	5	6	7

============================ 전체의 반복도 데이터 값의 -1




선택정렬

6	3	7	5
3	6	7	5
3	6	7	5
3	6	7	5

3	6	7	5
3	6	7	5
3	5	7	6

3	5	7	6
3	5	6	7





==============================================================================================================
4. 다차원 배열(2차원 배열 이상)

1차원 : 직접 접근
다차원 : 간접 접근


5. 불규칙 배열

	char name1[] = {'홍', '길', '동'};
	char name2[] = {'J', 'o', 'h', 'n', 's', 'o', 'n'};
	char name3[] = {'T', 'o', 'm'};
	char name4[] = {'J', 'a', 'n', 'e'};


	char[][] names = new char[4][7];

	----------------------------------------------------------

	동적바인딩(실행중에 열을 결정할 수 있다.)

	char[][] names = new char[4];	// 행의 크기만 일단 정해둠
	...
	names[0] = new char[3];		// 첫번째 행은 3열을 만들겠다.
	names[1] = new char[7];		// 두번째 행은 7열을 만들겠다.
	names[2] = new char[3];		// 세번째 행은 3열을 만들겠다.
	names[3] = new char[4];		// 네번째 행은 4열을 만들겠다.




6. String

(1) java.lang
(2) 동일한 인스턴스를 중복해서 생성하지 않는다. 중요*
(3) 절대로 수정 불가
(4) StringBuffer, StringBuilder

*note : 	수정이 불가능하면 계속해서 쓰레기를 생성할텐데 이대로 괜찮은가?
	그래서 새롭게 나온 것.

-스트링 버퍼는 수정이 가능하다.


7. 명령행 인자 (CommandLine Argument)

- 도스창의 커서의 깜빡임, 그것이 명령행
- 명령어 옆에 옵션같은 것을 인자(Argument)라고 한다.
- abc 라는 text 파일을 명령창에서 실행할 때 notepad abc.txt 여기서 abc.txt 가 인자가 된다
- 메인메소드에 String[] 스트링배열에 args 가 Argument이다.






day09~2.25

****************************************************************************************************
Class Part.2

//캡슐화의 보안성에 대해서 얘기해보자



1. 접근제어명시(Access Modifier) : 클래스, 메소드, 변수 등 어디에서든 사용할 수 있다.

ex) 접근할 수 있다. 접근할 수 없다.



(1) 종류

 *note 	: default와 public 은 접근 허용으로 사용한다.
	: private 과 protected 는 접근 거부용으로 사용한다.
	: 클래스를 보면 클래스 앞 아무것도 없으면 default, public 이 있으면 누구든 와서 입력가능

	1) default(anonymous) 

	: 생략된 키워드 - 접근을 허용하기는 하나, 제한된 접근을 말한다. (같은 폴더(=패키지)내 가능)
	

	2) public

	: 완전 접근 개방


	3) private

	: 완전 접근 거부


	4) protected

	: 제한된 거부



2. 메소드(Method) 

*note	: 메인 클래스 내에 메소드를 넣지말고 분리하는 훈련을 가져야한다.
	: public static void main(String[] args)
	: main 은 프로그램의 시작점 그리고 끝괄호 만나면서 프로그램을 종료
	: void 는 반환하지 않는다.
	: String[] args 명령행위를 처리하기 위해서 존재
	: public 얘가 없으면 자바가상머신이 이 클래스와 같은 폴더내에 있어야함.
	: static 은 나중에 알아보자.


(1) 인자 전달 방식


	- 값에 의한 전달(call by value) 

	: 직접 전달하는 방식(값이 크지 않는 경우, 갯수가 많지 않는 경우) 
	
		- 소량의 데이터
		- 잠깐 사용할 데이터
		- stack에 있는 값


	- 참조에 의한 전달(call by reference)

	: 데이터가 있는 주소를 알려주는 방식. 니가 갖다 써라~

		- 대량의 데이터
		- 오랫동안 사용할 데이터
		- Heap(인스턴스)에 있는 주소값




변수 - 배열 ---------------- 클래스


	배열의 단점

	1. 같은 데이터타입
	2. 크기
	3. 삽입/삭제가 거의 불가능하며 하지도 않는다.
	    - 삽입이나 삭제가 되면 배열은 연속적이기 때문에 뒤의 데이터들이 다 움직여야한다.
	


*note	: 변수는 선언만하면 쓰기 편하나, 하나의 값만을 저장한다는 단점이 있다.
	
	: 그래서 나온 것이 배열, 묶어서 저장하고 활용할 수 있다. 
	  하지만 같은 타입만을 묶을 수 있는 단점이 있다.
	  게다가 크기를 설정해 놓고 사용해야한다.
	  삽입/삭제가 거의 불가능하며 하지도 않는다.


	: 이러한 배열을 보완하기 위해서 나타난 것이 클래스
	  서로 다른 데이터 타입을 쓸 수 있다.
	  다만, 같은 데이터 타입이면 배열이 더욱 빠르다.
	  하지만 배열의 단점인 크기와 삽입/삭제는 클래스가 해결해주지는 않는다.

	: 크기 및 삽입, 삭제는 알고리즘을 통해서 프로그램을 코딩해야한다.




3. 재귀 호출(인터넷에서 찾아봐라)

4. static

- 클래스나 메소드 앞에 어디든 붙일 수 있다.(범위 내를 말하는게 아니다)

- 정말 필요한 곳에만 써야한다.

(1) 인스턴스와는 상관없이 별도의 메모리로 생성

(2) 여러 인스턴스들이 공유할 수 있는 메모리를 가진다.

(3) 클래스 변수라고 부른다. 
     (또는 스태틱 변수라고 부르면 된다. 다른 책에서 클래스 변수라고 나오면 그것은 스태틱변수)

(4) 반드시 클래스 내에서만 선언이 가능하다.

(5) static block : 묶어준다는 뜻, 뭘?
	
	
	static{
		static 변수들만 모아서 초기화 시킬 수 있는 그런 블록
	}



(6) 인스턴스를 가지고 있지도 않기 때문에 this가 존재하지 않는다.


5. 중첩 클래스(내부 클래스)

	중첩을 시키는 이유 : 내부 클래스 내에 나만이 사용하는 소스 등의 보안성 및 편의성을 위해서
			: 두개의 클래스를 동시에 사용하는 듯한 효과를 누릴 수 있다.
			: 중첩을 함으로써 코드를 깔끔하게 관리할 수 있다.


	내부 클래스 안에는 : 

	안에 있는 클래스에 따라서 두가지로 나뉜다.

	(1) 클래스

		:바깥에서 생성되야 안에서 만들 수 있다.

	(2) static 클래스



*. Scanner 클래스
*. Design pattern(짧은 경력을 보완할 수 있다)
	
	- Singleton Pattern : 인스턴스를 단 한개만 생성해서 쓸 수 있게 해주는 패턴

		-필요재료 : 생성자, static, private
		-사용방법 : 1) 외부에서 절대로 인스턴스를 생성할 수 없도록 만든다.
			   2) 클래스 내부에서 단 하나의 인스턴스를 생성한다.
			   3) 그렇게 만들어진 인스턴스를  외부에서 사용할 수 있게 한다.
*****************************************************************************************************************************

코드관리를 잘하자. 주석처리를 통해서 복사와 붙여넣기를 잘 활용하면 좋다.

	1. InheritanceTest
		-Cms 클래스 생성(을회사에서 개발)
		-상속받는 CmsExt 생성


** Inheritance(상속)

1.  상속 제외
	
 -상속이 되지 않는 항목이 두가지 있다. 두 가지를 제외한 나머지를 상속한다.


	(1) 생성자(자기 자신을 만들때 쓰는 것인데 상속이 가능한가?)

	(2) private(상속은 되는데 접근을 못해서 사용을 할 수 없다. 그러니 상속이 안되는 것과 다를바 없다.)

	- 위의 두 가지가 모두 안되면 최악의 상황으로 모든 데이터를 다시 작성해야한다.
	- 그래서 다음 방법이 가능하도록 되었다.


2. 부모의 생성자를 상속받진 못하지만 호출할 수 있다.(부모한테 보관시키고 필요할 때 꺼내온다.)

	super() : 부모의 생성자를 호출할 때 쓰는 메소드 그래서 필요한 데이터를 부모한테 넘겨줄 수 있다. 인자를 통해서.


	사용 형태는 아래와 같다.

	super.변수 또는 super.메소드() -> this 와 비슷하다. super는 부모의 주소를 this는 자기 자신의 주소를
	반드시 생성자 안에서만 호출가능
	반드시 첫줄에 작성


*상속이 어떻게 쓰이는지 흐름을 알아두는 것을 우선적인 목표로 하자.


3. 생성자 호출 순서

 - CallOrderTest.java 참고할 것.



4. 상속은 확장(extends)의 개념이다.

 - 똑같은 코드를 상속받아서 사용할거면 뭣하러 그러는가
 - 똑같은 코드에 추가 기능인 +@ 를 해주기 위한 것이 아닌가 그래서 extends라고 한다.



5. 상속은 단일 상속만 지원한다.

	상속설계

*note. 노트참고(단일, 다중 상속)

	- 단일 상속과 다중 상속
	
	: 상속을 받을 때 피해야하는 것은 중복이다. 즉, 기능의 중복을 최소화해야하는데,
	
	  다중 상속은 기능의 중복이 심했으며, 처음부터 완벽한 코딩을 구현해야했다.

	  자바에서는 다중 상속을 수용하지 않았으며 class와 사촌격인 interface에서는 다중 상속을 반드시 활용해야한다.


	- 상속 설계의 중요한 점

	  : 기능의 중복을 최소화할 것.
	  
	  : 부모클래스는 최소한의 기능으로 정의되어야 한다. (여러 자식들이 공통으로 가지는 것만 가져야한다.)
	    *note. 노트참고
	  
	  : 클래스는 하나의 기능으로 설계. (단일 기능으로 설계하라. 자신의 캐릭터를 명확히 하라. 머리는 머리, 팔은 팔, 다리는 다리)
	    기능의 최소 단위인 메소드가 모여 클래스를 이루는데 개성있게 메소드를 모아 모듈화하여 
	    클래스를 만들어야하며 이 클래스가 모여 컴퍼넌트라고 한다



6. 부모클래스와 자식클래스의 참조관계

	- ReferenceTest.java 참고


	(1) 인스턴스가 결정되지 않았을 때

		O, A, B(O는 A, B 의 부모클래스)
		
		- 만일 A라는 클래스의 인스턴스를 생성한다면 가장 바람직한 것은
		  : A a1 = new A(); 이다.

		  : 그리고 B라는 클래스의 인스턴스를 생성한다고 했을 때, 반드시 B가 오리라는 보장이 없다.
		    B b1 = new B(); 또는 new A(); 인데 서로 다른 클래스는 참조할 수 없다. 그러므로

		    O o1 = new B(); 또는 new A(); 로 생성하면 모두 수용할 수 있다. 이때 부모를 활용할 수 있다.


	(2) 여러 개의 자식 인스턴스를 배열로 관리하기 위해

		A a1 = new A();		-> 자식클래스
		B b1 = new B();		-> 자식클래스
		C c1 = new C();		-> 자식클래스
		D d1 = new D();		-> 자식클래스

		: 이런 경우 수정하려고 하면 모두 직접적으로 수정해야하는데 이때 부모를 활용하자.

		O o1[] = {a1, b1, c1, d1}; 

		게다가 O o1[] = {a1, b1, c1, d1, new E()}; 처럼 다른 곳에 흩어진 인스턴스를 넣어 활용할 수도 있다.

		: 부모의 이름 하나만 알면 4개의 인스턴스를 관리할 수 있다.
		  부모는 자식을 참조할 수 있기 때문에.

	(1) 서로 다른 클래스끼리는 참조할 수 없다.
	(2) 부모자식 간에는 서로 다른 클래스라 하더라도 참조가 가능하다.
	(3) 부모자식 간이라고 해도 자식이 부모를 참조할 수는 없다.
	(4) 부모는 자신이 물려준 재산에 대해서만 참조 및 접근할 수 있다. 자식의 고유한 데이터는 수정 불가능



7. 메서드의 오버라이딩(Overriding) : 재정의

오버로딩 & 오버라이딩 



공통점
 - 둘 다 메소드 내에서 사용한다.
 - 다형성을 지원하는 특징을 가진다.

차이점
 - 오버로딩 : 낭비가 심하다. (ex : 게임용 컴퓨터, 음악용 컴퓨터, 업무용 컴퓨터 등등)
	   : 메소드 내 어디서든 사용이 가능하다.

 - 오버라이딩 : 절약정신이 강하다(ex : 컴퓨터 하나를 사서 cpu 교체, 메인보드 교체 등등)
	      : 반드시 부모로부터 상속받은 메소드를 고쳐서 사용하는 방식(내것을 수정하는 것은 단순히 수정작업에 불과하다)




8. 추상클래스와 추상메소드(이것은 오버라이딩에서 파생된 문법이다)

	(1) 추상메소드

		1) 내용은 없고 선언만 되어있는 메소드를 추상메소드라고 한다.

			void a(){
					<- 이것이 추상메소드 입니까? - 아니다.
			}

		: 중괄호가 있으면 내용이없어도 안으로 진입하여 쓸데없는 행동을 한다. 이것은 낭비가 된다.
		: 즉, 추상메소드라하면 이러한 중괄호 자체도 없어야한다.

		: void a(); 이것이 추상메소드이다. 호출 아니다. 근데 이것 왜 하는 것인가?

			- 상속할 때, 쓸데없는 프로세스를 없애고자한다.


		2) 반드시 오버라이딩(고쳐야한다)을 해야 한다.(깜빡 잊고 수정하지 않은 것을 하도록한다. 안전장치의 의미)

		3) abstract 키워드 사용(앞서 쓴 void a(); 는 설명하기 위해서 저렇게 썼지만 abstract를 붙여줘야한다.)

			abstract void a();



	(2) 추상클래스

		1) 추상메소드를 한 개 이상 가지고 있는 경우 자동으로 추상클래스가 된다.

		2) abstract 키워드 사용하여 추상클래스가 된다.

			abstract class A{ ...


		3) 추상클래스가 되면 인스턴스를 생성할 수 없게 된다. 
		(클래스에게 인스턴스는 가장 중요하다. 자신은 일을 안하겠다는 말, 상속의 용도로만 사용되겠다. 라는 의미)



*6번부터 8번까지의 얘기를 종합예제로 해보자. ShapeTest.java




9. final(전천후 키워드, 어디에도 붙일 수 있다는 말)

 - final이 붙으면 수정할 수 없다는 공통속성을 갖는다. (메소드에 붙던, 변수에 붙던, 클래스에 붙던)
 - 데이터를 보호하자는 목적이 깔려있다.

	

	예) int i = 10; 
		
		i = 100; 이라고 수정이 가능하다. 하지만

		final int i = 10; 으로 앞에 final 을 붙이게 되면 10은 리터럴이 아닌 상수(constant)가 된다. i 는 곧 10이다. 바꿀  수 없음.


	예2) for(int i=0; i<100; i++){...	내가 반복을 100번 하겠다고 가정하자. 근데 100이라는 숫자가 가지는 의미를 아는가? 몰라.


		fianl int MAX_AGE = 100; 이라고 쓰고 MAX_AGE를 치환해서 쓰면 의미를 알 수 있고 가독성을 가진다.
		...
		for(int i =0; i<1MAX_AGE; i++){...



	예3) 그렇다면 메소드에 만든다고 가정해보자.
		

		final void method(){...	메소드를 수정하겠다는 것은 오버라이딩 하겠다는 말인데, final을 붙이면 그대로 쓰라는 말.



	예4) 마지막으로 클래스 앞에 붙인다면?

		
		final class Class{...		클래스를 수정한다? 어떤 의미? 상속하지마라. 상속해서 추가하고 확장하지마라. 내가 마지막 자식.




10. Object클래스

-java.lang.object

클래스 오브젝트는 클래스 계층도의 뿌리이며, 최상위 부모이다.
모든 클래스는 오브젝트를 부모로서 가지고 있다.

equals  : 비교
finalize  : 오버라이딩 
toString : 투영기능


================================================================================================================

3월 2일

도스에서 실행방법
패키지 bin폴더에서 java 패키지명.클래스명


**패키지(package)(= 폴더)

- 폴더 안에 만들었는데 그럼 그게 패키지? 노노
- 일반 폴더가 패키지화 하기 위해서는 클래스의 허락을 받아야한다.
-CLASSPATH 설정
- 압축을 해줘야한다. jar.exe 를 이용해서

	-c 새 아카이브를 생성
	-v 어떻게, 어떤 애를 얼만큼 압축을 했는지 보여준다.
	-f 압축 파일명을 내가 지정할 수 있다.
	-x 압축을 풀겠다.

1. 묶음을 의미한다.	(클래스를 묶어준다. 그 외에 아무 기능을 가지고 있지 않다.)

2. 사용효과

	1) 사용의 편의를 확보

	2) 중복된 이름의 충돌을 방지하기 위해서( A가 name을 쓰고 B가 name을 쓰면 충돌이 일어나는데 패키지로 묶으면 충돌x)

	




-------------------------
JAVA의 관례

클래스의 시작은 대문자로
패키지의 시작은 소문자로
메소드의 시작은 소문자로
-------------------------




** Protected(제한적 접근거부)

- 보안을 위해 private을 쓰면 상속을 포기해야했다. 
   이를 위해 protected가 나왔다. protected는 상속이 가능하지만 타인이 쓸 수는 없다. (자식만 쓸 수 있음)


========================================================================================================================

** Interface


- 표준화하기 위해서 쓰인다.(우리 이렇게 씁시다. 약속, 규칙 등등)
- 인터페이스 안에 있는 변수는 static 이라는 특성을 가지고 있다. 인스턴스화 되지 않았어도 쓸 수 있다.
- 인터페이스는 무조건 클래스의 부모다.
- 하지만 자식은 클래스다
- 인터페이스는 자신을 가져다 써주기를 바란다.
- 그래서 외부에서 가능한 많이 써주기를 바라기 때문에 public을 기본으로 한다.(protected와는 다름)

1. 클래스를 만들기 위한 설계도

2. 표준화를 위한 약속 또는 규칙

3. 문법적인 측면에서 순수(완전) 추상 클래스(하나가 아닌 모든 메소드가 추상메소드)
    (*추상클래스 :클래스를 생성할 수 없는, 추상메소드가 하나라도 있는, 자식에게 상속만을 하는)

4. 다중 상속을 지원한다.



========================================================================================================================

**유용한 클래스들(java.util)]	과제할 것.


Class Calendar(권장)
Class Date

Class StringTokenizer ('=. 같은 기능이지만 메소드와 클래스  split())


 - "aaa bbb ccc ddd"

 - 재분리하는 것을 파싱이라고 함. (ex) 가 -> ㄱ , ㅏ 


java.util.Random

Math


Class DecimalFormat 

 - 소수점을 정리해주는 클래스



Wrapper Class

- 포장해주는 클래스

	int i = 10;

	Integer i  = 10;

	i. 변수 //를 호출할 수도 있고

	i.메소드() // 를 호출할 수도 있다.'




변수 -> 배열 -> 클래스 -> Collection(클래스 + 알고리즘)


Collection

	- Set
	
	:  데이터를 보관하는 특징을 가지고 있다.

		- 정렬 순서가 없다.
		- 중복을 허락하지 않는다.
		- HashSet, LinkedHashSet(대표클래스)

			*SortedSet

				- TreeSet : 정렬기능을 가진 set ...

	- List

	: 데이터를 꺼내서 사용하거나, 출력하도록 해준다.

		- 정렬 순서가 있다. (order가 있다)
		- 중복을 허용한다. (보관을 신경쓰지 않았다.)
		- ArrayList, Vector, LinkedList, ... (대표클래스)

		: ArrayList는 데이터를 꺼내와서 활용할 수 있는 장점이 있다.



Map 

: Collection에 속하면 속하기도 하지만 collection 과는 다르게 독자적으로 사용된다.
: 두개의 데이터를 하나로 묶어서 저장한다.
: 데이터 검색을 위한 특화된 기능을 가지고 있다.


	- HashMap, HashTable, ....	

******************************************************************************************************************************************************
** Generic

java.util 에서 <E>가 붙은 타입들만 제너릭을 쓸 수 있다.


1. 용도
	1) 특정 타입(객체형)을 미리 검사
		
		- 사전에 잘못된 데이터 타입을 미리 체크

	2) Template


2. 문법



	1) 만드는 문법

		class 클래스명<이름>{...


	2) 사용하는 문법

		클래스명<데이터타입> 변수 = new 클래스명<데이터타입>();



******************************************************************************************************************************************************

** 예외처리

(참고 ExceptionTest)


- 예외가 발생했을 때 예외에 대한 제어권을 시스템(JVM)이 아니라 개발자가 가질 수 있게 하는 방법

1. 왜 쓰는가?

	1) 예외가 발생했을 때 메시지에 대한 표현 문제
	2) 프로그램의 비정상적인 종료

2. 키워드

(1) try/catch block(★핵심도구)

	try{
		...
	}
	catch(...){
		...
	}


(2) throw

- 일부러 에러를 발생시킴으로써 예외처리가 잘 되는지 확인하기 위해 사용한다.
- 예외처리를 다른 곳에서 하도록 사용한다.
- 메소드 안에서, 특히 블록{} 안에서만 사용해야한다.
- 예외를 하나만 던질 수 있다.


(3) throws

- 메소드 밖에서만 사용해야한다.
- 예외를 여러 개 던질 수 있다.
- 에러를 발생시키는 것은 아니다.
- 예외가 발생했을 때 다른 애에게 대신 처리하도록한다.


(4) finally(block) 중괄호를 써야한다.

	- try/catch와 반드시 같이 사용해야한다. throw, throws와 같이 별도로 사용할 수 없다.
	- 반드시 실행을 보장받을 수 있는 영역을 의미한다.


3. 클래스 유형

Throwable
(예외처리 내에서 가장 우두머리 클래스)

	Throwable이 가지는 Method summary

	- getMessage()
	- printStackTrace()
	- toString()



subclass	- Error
	
	- Exception
		- RuntimeException






******************************************************************************************************************************************************

Tip: 패키지는 소문자로 만든다.
------------------------------------------------------------------------------------------------------------------------------
**IO(Input Output) : 입출력

궁금한가? java.io 패키지로 찾아가보시게

1. java.io
2. Stream(흐름, 시냇물) 구조

	(1) 단방향(한쪽방향 ex:무전기) -> 중요

	(2) 원칙적*으로 순차적이다.(정해진 순서 ex : 노래테이프) -> 중요
		(*예외가 있을 수 있음)

	(3) 지연 발생 가능 - 항상 같은 속도로 흘러가지는 않는다. 빨리질 수도 있고 딜레이될 수도 있다.

	(4) 어떤 장치를 사용하던간에 사용법은 거의 동일하다.

3. 자바에서 제공하는 Stream방식

	(1) byteStream 방식(stream 방식은 사실 byte방식 하나만 존재한다.)
		
		: 1 byte씩 쪼개서 흘러들어가고 흘러나온다. - 기계가 쓰기 좋아하는 방식

		
		Java에서 어떻게 구현했는가?
		
		1) OutputStream(추상클래스)

		2) InputStream(추상클래스)

		-------------------------
		FileInputStream
		FileOutputStream

		DataInputStream
		DataOutputStream

		RandomAccessFile

		ObjectInputStream

		ObjectOutputStream


	(2) characterStream방식('=. 필터클래스, byte 클래스를 포장하기 위해서 등장했다. 사람이 쓰기 좋게)

		-클래스가 클래스를 포장하여 보안하고 확장해주는 기능을 가진다.
		-wrapper 클래스는 객체가 아닌 비객체들을 포장하여 객체처럼 쓰도록 한다.
	
		: 문자단위로, 유니코드로, 2 byte를 기준으로 흘러들어가고 흘러나온다. - 사람이 쓰기 좋은 방식

		1) Writer

		2) Reader

		-------------------
		FileWriter

		FileReader

		InputStreamReader



	*. PrintStream

		-출력


		flush 버퍼에 잠시 저장해두었다가 꽉 차면 출력한다.



	*. Serializable(java.io 내에 있는 인터페이스, 직렬화)

		public interface Serializable{
		}


	*.PrintWriter

		문자스트림으로 출력하는 기능을 가지고 있다.
		출력에 대한 최대의 편의성을 제공하고 있다.
		가장 쉽게 사용자들이 출력해주도록 한다.


		- 자체적으로 파일에 입력하는 기능을 갖추고있다.
		- 운영체제에 대해서 \r\n 을 써줬어야했는데 printwriter는 println도 지원하므로 줄바꿈이 가능




	*.File


				====	the End of I.O	=====
******************************************************************************************************************************************************

(03.09.wed) 쓰레드 시작

** Thread(쓰레드)

	: 쓰레드를 이해하기 위해서는 운영체제를 이해하는 것이 중요하다.



먼저 짚고넘어가자.

1. Program And Process

	: 프로그램과 프로세스의 차이는 '실행'이다.
	  실행되지 않은 것은 소프트웨어적인 프로그램이지만 소프트웨어를 더블클릭하여 실행하면
	  이 프로그램은 프로세스로 바뀐다.

	: 실행하면 프로그램은 메모리(램)에 등록되어 프로세스된다.
	
	*윈도우 작업관리자에서 확인할 수 있는 프로세스를 보면 여러 실행중인 프로그램이 존재한다.
	  이를 멀티프로세스라고 한다. 윈도우의 등장으로 이와 같은 기술이 가능해졌다.
	  즉, 운영체제를 바탕으로 멀티프로세스가 가능하다는 말.


	Multi Process(프로그램이 여러개 실행중이다)
	Multi Processor(여러 CPU가 있다.)


2. Process(우리가 신경쓸 것은 단일 프로세스)


	: 하나의 프로세스 내에서 실행되는 작업의 단위를 쓰레드(Thread) 라고 한다.
		작업의 범위는 내가 정할 수 있다.
		여러 작업을 할 수 있다는 것을 멀티 쓰레드라고 한다.

	: 하나의 프로그램 내에서 여러 작업을 할 수 있도록 하는 방식
		ex) 한글 프로그램에서 프린트 출력을 해도 작업을 할 수 있는 것.


	: 멀티쓰레드는 게임같은것에서 가장 많이 쓰인다.(실시간으로 총을 쏘고 피하는 것처럼)
	
	*사실 멀티쓰레드는 여러가지 동작을 동시에 실행되게 하는 것은 아니다. 이것은 물리적으로 불가능하다.
	  cpu는 한번에 한가지의 일을 할 수 있도록 되어있다. 동시에 실행되는 것과 같은 효과를 거두기 위해서
	  시간의 배분을 동일하게 주고 그 동작을 빠르게 처리함으로써 마치 동시에 일어나는 것처럼 보이도록 한다.

	  쓰레드에게 쉬는 시간을 준다.(=Idle Time) 쉬는 시간에 다른 쓰레드가 일을 할 수 있도록한다. 이를 빠르게 반복하면
	  동시에 실행되는 것처럼 보인다.
	  1번 쓰레드의 동작 내에 쉬는 시간을 설정하면  cpu는 2번 쓰레드로 가서 일을하고 2번쓰레드에서 쉬는 동작을 만나면
	  다시 1번 쓰레드로 간다. 이를 반복한다는 말.
	
*.Note
	모든 프로그램은 반드시 기본적으로 한개의 쓰레드를 가지고 있다.
	(쓰레드가 없다는 것은 작업하는게 없다는 것, 프로그램 존재 이유가 없다)
	여기서 말하는 반드시 가지는 한개의 쓰레드는 main()을 말하고 있다.


- 어떤 식으로 처리하는가?
3. 처리 방식

	(1) Thread 클래스를 상속하여 처리(가장 간단하며 쉽다.)
		-Life Cycle을 말하기에 앞서 먼저 Thread 클래스를 활용한 자바를 만들어보자.

	(2) Runnable 인터페이스를 상속하여 처리
	(다른 클래스를 상속 받을 때 중복으로 상속받을 수 없으므로 인터페이스를 활용할 수 있도록 한다.)


	
*.Note

	Thread의 Life Cycle


	동기화
	
	: 노트 참조(원드라이브 업로딩함)	
	: 동시접근을 어떻게 막아야하는가...?


4. synchronized(동기화)

 -사용방법 :

	(1) synchronized 메소드

	(2) synchronized(공유객체){
		코드들...
	     }
		
		:변수에 싱크로나이즈드를 붙일 수 는 없지만 위 처럼 특정 코드에는 붙일 수 있다.



5. Thread의 강제종료


	(1) stop()

		:왠만하면 쓰지말자. 너무 심하게 강제종료함. 자바에서도 비사용을 권함.

	(2) interrupt()

		:stop보다는 약간의 텀을 주기 때문에 stop을 쓸바에 인터럽트를 써라.

	(3) 직접 제어

		:내가 직접 코드로 제어할 수 있다. (안드로이드에서는 이 방법을 권장함)





6. 종료시점(FinishTest.java참고)

Thread의 종료시점을 처리하는 방법에는 두가지 방법이 있다.

	(1) isAlive() : 메인을 마지막으로 끝내게한다.

	(2) join() : 어떤 지연장치 및 조건 없이 자식스레드가 종료되고 메인이 종료된다.



7. ThreadLocal




8.무명클래스

	: 이름이 없으며 한번 갖다 쓰고 말거라서 그렇다.
	: 이름없이 클래스를 만든다.
	: 안드로이드에서 많이 쓰인다.


End of the Java
***********************************************************************************************************************
**자바의 활용


1. Windows Programming


	(1) 윈도우 프로그래밍을 하기 위해서 가장 먼저 필요한 것은 '재료(=component)'의 파악이다.

	(2) 그 재료를 가지고 어떤 모양을 꾸밀 것인가에 대한 '디자인(=Layout)'

	(3) 버튼을 누르면 무엇이 움직이고 '동작(Event)'을 구현하는 것

	위의 세개가 윈도우 프로그래밍의 3요소.


2. Component(재료의 포괄적인 의미)

	(1) AWT(=Abstract Window Toolkit, 세부적인 재료의 의미, 윈도우를 구성하는 재료라고 생각하면 될 것.)
		
		java.awt.Component(awt의 가장 부모격)

		Button
		Canvas
		Checkbox
		
--------------------------------------------------------------------------------------------------
		Container		
		: 다른 component들을 담기 위한 그릇을 제공한다. 자신의 모양을 가지고 있지 않다.
		: 아래의 어느 컨테이너에 담느냐에 따라서 component들의 성격이 달라진다.
		: component들을 담으면 어떤 성격을 띄는가? 아래를 확인하시오.


			Panel
				Applet : 인터넷 프로그램('=.ActiveX) but, 이제 안써. 인터넷 브라우저에서 실행조차 안됨.




			Window	: 윈도우는 많이 안쓰며 자식인 프레임을 주로 쓴다. 

				Dialog

					FileDialog

			
				Frame : 이곳에 담으면 응용프로그램('=. 어플리케이션)이 된다.


--------------------------------------------------------------------------------------------------

		Label	: 문자만 출력하는 기능을 가진다. (제목을 보여주거나...)

--------------------------------------------------------------------------------------------------
		List	: 선택할 수 있는 창을 모두 보여주는 창(단일, 다중 선택이 가능함)
		Choice	: 선택할 수 있는 창을 숨기고 마우스로 버튼 클릭시 아래로 보여줌.(단일 선택만이 가능하다)
		
		


		Scrollbar

--------------------------------------------------------------------------------------------------

		TextComponent	: 텍스트 컴퍼넌트를 직접쓰지 않고 자식을가져다 쓴다.

				

				TextArea : 여러줄을 입력할 수 있는 텍스트 박스이다.
				

				TextField : 아이디나 비밀번호와 같이 한줄의 입력 박스를 일컫는다.




--------------------------------------------------------------------------------------------------



(2) Dialog(대화상자)

	1) Custom Dialog	: 사용자가 임의대로 디자인 할 수 있다. (커스터마이징)
	2) Common Dialog	: 공통적, 이미 만들어진, 일반적인 Dialog
	3) 실행 방식


		- modal : 현재 실행중인 다이알로그를 종료하지 않으면 절대 다른 동작을 할 수 없는 방식 ex: 파일오픈창 열면 다른거 못함.

		- modaless : 현재 실행중인 다이알로그를 종료하지 않아도 다른 동작을 할 수 있는 방식 ex: 찾기
	

			- modal이  modaless 보다 쉽다. 창이 열리면 락을 걸고 얘만 신경쓰면되거든, 프로그래밍하기 쉽다.
			  특별한 경우에만 modaless를 사용한다.




3. Layout(=배치, 디자인)

- 일단 배치를 하기 전에 container를 배워야할거다.
- 그리고 layout을 배우자.

	위에서 처럼 container 에는 애플릿과 프레임이 있다. 애플릿은 더이상 쓰이지 않는다.
	복습할때는 컨테이너부터 순서를 참고하는 것이 좋을 것이다.


(1) LayoutManager

	: 크기의 변경에 따른 좌표 계산 등을 해주는 녀석
	Flow 와 Border가 가장 기본이며 많이 쓰인다.

	1) FlowLayout	: 순서대로 배치하는 방식(왼쪽에서 오른쪽으로, 위에서 아래로) 패널계열은 플로우레이아웃 형식
	2) BorderLayout	: 테두리를 기준으로 배치하는 방식(동쪽,서쪽,남쪽,북쪽,가운데)
	3) GridLayout	: 행과열을 기준으로 배치한다.
	4) GridBagLayout
	5) CardLayout	: 탭화면처럼 하나씩 보여주는 레이아웃이며 이벤트가 필요하다. 누르면 한화면만 보여야하니까 



4. Event

(1) 이벤트의 3요소

	1) 이벤트 소스(위치, 컴퍼넌트) : 가장 필요한건 사건이 일어난 위치와 장소. 소스란 그 장소를 의미한다.
			
			- 마우스 포인터로 버튼을 눌렀을 때, 그것은 사건이 발생한 것이라고 하면 그곳으로 가는게 중요하다는 말.
			- 그 사건이 발생하는 장소가 되는 재료들 such as 버튼, 박스 등등을 컴퍼넌트라고 일컫는다.

	
	2) 이벤트 클래스(종류) : 어떤 사건이 발생했는지? 유형 및 종류를 의미한다.

		이벤트의 부모는 특이하게 java.util.EventObject 클래스로 정의되어있다.
				자식은 java.awt.AWTEvent

				신경써야할 이벤트 	ActionEvent
							컴퍼넌트(대상)가 활성화 될 때 발생하는 이벤트(비활성화에는 대응할 수 없다. 선택만 반응 해제에는 무반응)
							(ex : 윈도우창을 선택하면 창의 색이 진해진다. 이를 액션이벤트라고함)
							(ex : 버튼의 tab키의 경계점선도 활성화 된 액션이벤트라고 생각하면 된다.)
							(ex : 이벤트는 여러개가 중복이 된다. 여러개의 이벤트 중 무엇을 선택해야하는가?
								버튼을 클릭하면 액션이벤트와 마찬가지로 클릭이벤트도 발생, 무엇을 선택?)

						AdjustmentEvent
							무엇인가를 조정하는 이벤트
							(ex : 스크롤바와 같이 조정 가능한 컴퍼넌트에서 조정이 일어날 때
								발생하는 이벤트)

						ComponentEvent - 컴퍼넌트 이벤트는 본인보다 자식을 주로 사용한다.

								ContainerEvent(자주사용안함)
									컨테이너에 컴퍼넌트가 추가 /삭제되는 경우에 발생하는 이벤트
									(ex : 디자인을 미리 해놓은 경우가 아닌 실행 중에 디자인이 바뀌었을 때(추가/삭제))
									
								FocusEvent(자주사용함)
									컴퍼넌트에 포커스가 들어왔을 때 발생하는 이벤트
									(ex : 커서의 깜빡임, 버튼 테두리의 점선들)

								InputEvent
									KeyEvent(키보드에서 입력할 때 발생하는 이벤트)
									MouseEvent(마우스에서 가능한 모든 행위에 대한 이벤트)

								PaintEvent
									컴퍼넌트가 그려져야할 때 발생하는 이벤트
									(ex : 여러개의 윈도우 창이 있을 때, 포개놨다면 뒤에 가려진만큼은 사실 그림이 없다. 
									모니터가 2D이기 때문인데, 올려져있는 창을 옆으로 옮겼을 때 밑에 가려져있던 창에 원래 그림이나 글이
									바로보이는 것은 치우는 동시에 바로 그리기 때문이다. 그때 발생하는 이벤트를 페인트이벤트라 한다.)

	
								WindowEvent

									윈도우가 활성화, 또는 닫힐 때 발생하는 이벤트
									(ex : 윈도우에서 창을 2개 띄워놨을 때 두개를 활성화 시킬 수 있는가? 하나만 가능하다. cpu는 하나씩만 처리가능하므로)



						ItemEvent
							리스트, 초이스와 같이 선택항목이 존재하는
							컴퍼넌트에서 선택항목이 선택될 때 발생하는 이벤트
							(ex: 선택가능한 항목을 가진 리스트에서 선택할 때 발생하는 이벤트)
							(ex: 액션이벤트와는 달리 선택과 해제에도 반응할 수 있다)


						TextEvent
							텍스트 컴퍼넌트의 내용이 변화될 때 발생하는 이벤트



	3) 이벤트 핸들러(처리, 리스너(Listener) 인터페이스) : 	위치와 어떤 종류의 사건인지 알았다면 남은 것은 처리. 
							처리는 어떻게 처리를 해야할지 모르므로 내용을 미리 만들어둘 수가 없다.
							그래서 인터페이스로 처리하게 되겠다.
							어떤 일이 발생하면 귀기울여 듣고, 주시하고 있다가 처리하는 리스너 인터페이스

							java.awt.event를 참고하면 해당 사건, 이벤트가 일어나면 처리하기 위한 인터페이스들의 이름이 정해져있다.



							*PanelTest의 주석 참고(이벤트 순서에 관한 내용)



(2) 이벤트 코드 처리 방식(참고 EventTest2.java)


	1) 이벤트 소스와 핸들러가 같은 클래스인 경우		<-같은 클래스인 경우(1)
--------------------------------------------------------------------------------------
	2) 이벤트 소스와 핸들러가 다른 클래스인 경우			(*2다른 클래스들과 함께 쓰일때)

	3) 이벤트 소스와 핸들러가 내부 클래스인 경우		<- 다른 클래스인 경우(3)

	4) 이벤트 소스와 핸들러가 무명 클래스인 경우			(*3,4 혼자서 쓸 경우)


(3) 이벤트 소스와 핸들러의 연결

	이벤트소스.addOOOListener(핸들러의 주소);
	(*여기서OOO은 클래스이름)



(4) Adapter Class(코드를 좀 더 짧게하기 위해 몸부림하는 방식 중 하나)(참고 AdapterTest1.java, WindowClosing.java)

	: 불필요한 오버라이드들을 따로 저장하고 필요한 오버라이드들만 전달해주는 클래스
	: 도큐먼트를 참고하면 Adapter가 붙어있는 애들은 오버라이드할 메소드들이 두개이상인 애들이며
	: 오버라이드할 메소드가 하나뿐인 애들은 adapter가 붙어있지 않다.



(5) 그외 이벤트들...(TextEvent, KeyEvent, ItemEvent)


3.15 신호등 과제


(6) 메뉴

	1) Pull Down Menu(누르면 위에서 아래로 떨어지는 메뉴, 고정식이라고 한다.)

		: 아래 세가지가 조립되어 하나의 메뉴를 구성한다.
			
			- 구성요소
				
				MenuBar	(ex:파일 편집 서식을 구성하는 긴 Bar)
				Menu	(ex:파일 편집 서식 자체를 Menu)
				MenuItem(ex:새로 만들기, 열기, 저장 등 실제 동작을하는 MenuItem)

	2) Popup Menu(화면에서 툭 튀어나오는 듯이 출력되는 메뉴, 마우스 우클릭한거랑 비슷하며 이동식이라고 함, 또는 Context Menu라고 한다.)

		- 구성요소(메뉴바 필요없다. 메뉴바가 있다는건 고정이란건데 얘는 이동식이니까)

			PopupMenu
			MenuItem




----------------------------------------------------------------------------------------------------------------------------------------------------------------------------

**Swing : AWT는 3.1부터 사용되어온 윈도우의 기본틀이었는데, 지금의 윈도우 버전을 충족시키기에는 부족함이 많다.
	이를 보완해서 등장한 것이 Swing이며 AWT는 사실 사용되지 않고 Swing을 쓴다.
	AWT를 사용하기 위해서는 C언어를 병행해야했기 때문인 이유도 있다. Swing은 100% JAVA의 기술로 되어있다.


1. 스윙은 클래스명에 J자가 붙는다 만일, JButton, JFrame,... 모두 스윙이다.)
2. 패키지가 javax 로 시작한다. javax.swing
3. 스윙은 *MVC(Model View Controller) 라는 패턴을 적용시켜 클래스를 만들었다. 자신이 맡은 바 일을 하겠다. 주어진 일을 수행하겠다.
	
		Model = Data,  View = Design

		위 처럼 데이터와 디자인을 분리하여 역할을 수행한다.

http://programmingsummaries.tistory.com/61	//gui구현

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------
3월 17일
책을 보려면
시스코네트워크


** 네트워킹


1. 네트워크란?

-두대이상의 컴퓨터가 선으로 연결되어있어야한다.
-이것이 여러 컴퓨터와 연결되어 그물(net)처럼 보인다.
-이 선이 살아있어 서로간의 작업(work)이 가능해야한다.
-이를 네트워크(network)라고 한다.

	1-1. 네트워크를 구성하는 방식

	(1) 도메인	: 하나의 서버를 두고 여러 클라이언트를 가지는 방식
			: 서버란 내가 가지고 있는 정보를 다른 사람에게 줄 수 있으면 그것을 서버라고한다. (서비스를 주는 것)
			: 클라이언트 서비스를 받는 대상
			: 어떠한 경우라도 서버가 먼저 클라이언트에게 정보를 주는 경우는 없다. 클라이언트의 요청이 있어야한다. 1. 클라이언트의 request -> 2. 서버의 response
			: 도메인 환경은 서버 하나를 두고 클라이언트의 자리가 바뀌어도 어디서든 작업을 할 수가 있다. ex) 클라우드
			
	(2) 워크그룹	: 어떤 대상이 요청이 되거나 서비스를 제공하느냐에 따라서 서버냐 클라이언트냐로 나뉘는데 누구든 서버가 되고 누구든 클라이언트가 될 수 있는 방식을 워크그룹이라한다.
			: 이러한 워크그룹 방식을 peer to peer 라고하며 약자로 p2p 라고 한다. ex) 소리바다, 토렌트



2. Protocol(프로토콜)	: 협정서라고한다. 기업과 기업간의 약속과 같은.

	1) TCP/IP*	: 인터넷에서 할 수 있는 모든 약속이 있다.
	2) http		: HyperText Transfer Protocol 문자를 누르면 문서가 나타나는 기능.(html을 볼 수 있도록한다)
	3) 그외 여러가지
	4) IPX/SPX	: 스타크래프트에서 사용하던 컴퓨터간의 연결, 굉장히 빠르다. 


3. OSI 7계층	-(변화, 7번의 포장이 필요없다 줄이자.)- >	인터넷 계층(=TCP/IP, 4계층)

4. TCP / IP	:하나의 프로토콜이 아니다. 수십개 수백개 이상의 프로토콜을 묶어서 하나의 대표이름인 TCP/IP로 정한 것이다.

		: TCP 와 UDP 는 기본적으로 알아야한다.
		: TCP 는 연결지향성이며(안정성 우선시, 데이터 전송실패에 대해서는 재전송을 한다.) UDP는 비연결지향성이다.(속도를 우선시한다)(그림참고할 것)
		: 데이터를 보내는 단위를 패킷이라고 한다.(그림참고)


5. IP		: 크게 두가지의 버전을 가진다.

		v4	0~255 . 0~255 . 0~255 . 0~255	현재 v4는 주소가 모두 고갈됐다. 2^8 . 2^8 . 2^8 . 2^8 = 32bit 주소체계

		v6	위와 같은 방식으로 128bit 주소를 가지고 있다.

		: 또한  Real IP 와 Virtual IP(한정된 지역내에서 사용 가능한 가상 IP, 로컬네트워크)를 가진다.

			Real IP 는 Static IP(고정아이피), Dynamic IP(유동아이피)로 나뉜다.
			
			유동아이피는 한정된 아이피를 효율적으로 배분하여 할당한다. 사용자가 10명인데 이 모든 사용자가 동시 접속하지 않기 때문에
			사용하는 컴퓨터에 그때 그때 주소를 할당해준다. 그래서 주소의 변동이 일어난다. 그런데 이와 같은 관리를 사람이 직접할 수 없기 때문에
			이 관리를 해주는 서버를 따로 마련해뒀다. 이를 DHCP 서버라고 한다.


		: 다른 컴퓨터의 IP 주소를 알면 해당하는 컴퓨터로의 접속은 가능하지만 그 안의 프로그램으로는 접속이 불가하다.
		: 그곳으로 접속하기 위해서는 port라는 것을 알아야한다.
		: port는 운영체제에서 관리해준다.

		:위에서 언급한 IP 와 Port 를 따로 설정하거나 관리하는 것은 너무 번거롭고 복잡하다. 이를 하나로 묶어서 관리하는 것을 소켓이라고 한다.

		: 도메인 주소를 IP 주소로, IP 주소를 도메인주소로 변환해주는 것을 DNS(도메인 네임 서버) 라고 한다. 202.179.177.22 (=www.naver.com)



================================================================================================================================================================================================


서버용 프로그램 만들기


================================================================================================================================================================================================




16-03-21 

DB 설치, 두개의 파일을 하나의 폴더에 풀기


DataBase

1. 정의 : 데이터베이스란 무엇인가? 데이터의 집합체

	삽입
	삭제
	수정
	조회

	위의 네가지를 DB의 기본연산이라 하며, 이 기능의 항목을 가져야 데이터베이스라 할 수있다.
	단순히 데이터만을 집합해놨다면 찾을 수가 없고 수정할 수가 없으며 삽입할 수가 없다.

	------
	DBMS

		- Oracle
		- MS-SQL server
		- Infomix
		- DB2
		- ...





2. 오라클 도큐먼트 활용

http://docs.oracle.com/cd/E11882_01/index.htm

3. 저장형태에 따른 구분

	(1) 계층형 DB(HDB : Hierarchy Data Base) - Tree형

		: 트리 구조상 검색의 속도에 문제점을 발견. 최상위로 올라가 다시 내려가야함.

	(2) 네트워크형 DB(NDB : NetWork Data Base) - Graph형(순환)

		: 트리 구조의 단점을 보완한, 네트워크형 최상위로 올라가지 않고 바로 검색이 가능함.
			- 단점 : 너무 복잡하며 따라서 유지보수가 어렵고 바로 검색하기 위해서는 알고리즘이 필요함.
			            일반 사용자에게 널리 사용되지 않았음.

	(3) *관계형 DB(RDB) - Table형
		field < record < table(파일) < 데이터베이스
		
		: 여러개의 필드를 묶어서 레코드, 레코드를 묶어서 테이블, 레코드는 메모리에 저장되지만
		: 테이블은 실제로 파일로 저장되는 단위가 된다. 이러한 테이블의 파일들이 수백 수천 수만이 모여 데이터베이스를 이룬다.

	(4) 객체지향형 DB(ODB)

		: 객체지향형은 개발자들도 어려운데 DB관리자들이 다루기엔 더 어려워 자리를 잡지 못했다.
		: 그래서 관계형을 주로 많이 다뤘다.
		: 객체형과 관리형을 퓨전한 버전으로 아래의 객체관계형이 등장하게 되었다.
		: 하지만 아직도 관계형이 많이 쓰이며 우리는 관계형에 대해서 공부하기로 한다.

	(5) 객체관계형 DB(ORDB)



4. SQL(Structured Query Language)

	: 데이터 베이스 처리용 전문언어

	(1) 비절차적

		: 만일 자바로 검색을 한다면 클래스를 찾아 반복문을 돌리거나 코드에 대한 절차가 필요한데,
		: SQL은 그러한 절차를 갖지 않고 간단하다. 그래서 비절차적. 절차에 대한 과정을 줄였음.
		: 질문하듯이 던지는 언어.
		: 여러개의 언어를 하나로 묶어 구성했다.

	(2) 구성언어
		
		1) DDL(Data Definition Language) : 정의어, 데이터베이스를 사용할 수 있는 환경을 준비해주는 언어.

			- CREATE 	: 생성
			- DROP		: 삭제
			- ALTER		: 수정

		2) DML(Data Manipulation ...) : 실제로 데이터를 가지고 다루고 제어하는 언어(개발자에게 빈번하게 사용되는 언어 QL 포함해서)

			- INSERT		: 삽입
			- UPDATE	: 갱신
			- DELETE		: 삭제

		3) DCL(Data Control ... ) : 데이터가 잘 돌아갈 수 있게끔 제어해주는 언어. 보안 및 백업 등을 제공한다. (관리자 전용 언어)

			- GRANT		: 권한부여
			- REVOKE ...	: 권한제거

		4) QL (Query ...)

			- SELECT




5. DB를 시작하기 전에...


	(1) 접속방법	: 접속툴(tool)이 필요하다. 아래 두가지의 툴이 있음.

		1) Console(도스화면 직접 명령하여 사용)

			- SQL*PLUS(강력한 기능을 제공~)

		2) GUI(윈도우)

			- SQL Developer	: SQL*PLUS 만큼은 아니지만 좋다.

			- Toad		: 오라클의 전설적인 접속툴(오라클을 원격접속할 때 사용하는 툴)

			- SQLGate,...
			
			- Eclipse




	(2) SQL*PLUS

		1) 사용방법(접속 및 해제)

			

			sqlplus 사용자 id

				
				: 비밀번호 1111

			sqlplus 사용자 id/패스워드

				: 도스화면에서 sqlplus(사용자모드)/1111 sqlplus system(관리자모드)/1111로 접속할 수 있다.

			sqlplus 사용자 id/패스워드@host명

				: 서버에 접속할때 뒤에 @호스트명을 써준다.
				:  ex) conn scott/1111@orcl	(orcl 은 변수명이다. 이 변수명은 어디있는가?)			
	
			sqlplus scott/1111@teacher


				exit, quit		접속을 종료한다.
				connect scott	scott으로 접속가능하며
				connect hr/1111	hr로도 접속이 된다 패스워드까지 함께 입력해서
				conn system/1111	conn 이라는 약자를 사용해서 접속할 수있으며 관리자로 접속할 수 있다.
				show user	나의 접속 상태를 볼 수 있다.

			
			*현재 내 컴퓨터는 서버도 되고 클라이언트도 되는 환경이다.
			
			C:\app\USER2\product\11.2.0\dbhome_1\NETWORK\ADMIN 에서

				- 서버용인 listener를 열어보면 localhost로 되어있으며
				(내 컴퓨터니까 외부에서 접속하려면 localhost가 아닌 내 아이피가 있어야한다.)

				- 클라이언트용인 tnsnames를 열어보면 orcl로 되어있다.


			*강사용의 서버를 일단 만진다.( 학생들꺼는 안만지고 요약만한다.)
	
			- 서버

			1. listener 아래의 문장을 복사함. ( description을 하나더 만든다.)
			2. 아래 문장의 localhost를 지우고 자신의 ip를 등록한다. ipconfig 서버측임을 주의하라.


			- 클라(내가 할것)

			1. ORCL 아래 문장들 복사하여 하나더 만들고 TEACHER로 만듦.
			2. 강사님의 ip주소를 localhost에 입력하고 저장 서비스 리스너를 다시 시작





		2) 계정 사용가능

			SELECT username, account_status From DBA_Users;


			ALTER USER PM ACCOUNT UNLOCK;
				(PM락을 풀어주겠다)

			ALTER USER PM IDENTIFIED BY 1111;
				(접속하기 위해 비밀번호가 필요하니 비번을 설정해주겠다)


			SELECT tname FROM tab;


		3) 새로운 계정 추가 / 삭제


			CREATE USER test1 IDENTIFIED BY 1111;
				(새로운 계정의 이름으로 비번까지 설정해서 만들겠다)

			GRANT CONNECT TO USERNAME;
				(새로운 계정에 접속할 수 있는 권한을 부여하겠다)

			CREATE TABLE tbltest(id number);
				(새로운 계정에 테이블을 만들겠다.)

			GRANT resource to test1;

			DROP USEr test1(username);
			삭제해도 되는지 확인되었으면 DROP USER user명 cascade; (무차별삭제)
		


		4) 관리자 비번을 분실하였을 경우
		
			system as sysdba
			/ as sysdba
	
			위 처럼 접속해서 비밀번호를 변경할 수 있다.
			그렇다면 누구나 이렇게 접속해서 비밀번호를 바꿀 수 있는가?
			아니다. 로컬에서만 접속이 가능하며 네트워크에서는 불가능하다.

			비밀번호 변경은 alter

		5) 명령어 작성 방법

			- 메모장을 호출하여 작성
			
				edit test1
			
				start test1
				(= @test1)

				edit f:\java\test2
				@ f:\java\test2


	edit username 을 쓰면 username의 이름으로 메모장 파일을 생성하고 
	그 안에 명령어를 적고 저장한 뒤 start username을 적으면 
	메모장 내의 명령어가 실행된다. 확장자는 sql 임을 주의해야한다.

	여기서 start 대신 @username 을 써도 된다.

	파일의 생성을 위해 디렉토리를 써줘도 된다.
	ex) edit f:\java\test2.sql
	실행하기 위해서 디렉토리 주소를 써준다 ex) @f:\java\test2.sql


5. SELECT
(1) 데이터 검색

(2) 기본문법


	SELECT 필드명,... FROM [소유자].테이블명	-> 원하는 필드를 검색하겠다. ... (=여러개의 필드)
	----------------------------------------
	
	설명:
	
	scott 의 tname (테이블네임)

	Bonus 		-> 비어있음
	DEPT		-> 부서
	EMP		-> 직원(가장많이쓰임)
	SALGRADE	-> 급여등급


	위의 항목에 대한걸 설명받고싶으면 descript 줄여서  desc 항목명 ex) desc emp


	select empno, ename, sal from scott.emp;
	검색하겠다 사번과 사원명, 급여를 scott.emp로 부터
	만일 접속자가 scott 본인이라면 뒤에 scott 은 생략가능하다. emp는 넣어줘야함

	system(관리자)도 사용자명을 적어줘야 검색이 가능하며 다른사용자(hr)은 scott의 대한 정보를 검색하기 위해선
	권한을 관리자로부터 부여받아야한다 ex) grant on scott.emp to hr


	SELECT * FROM 테이블명(선택 필드명 테이블명)
	------------------------
	select * from emp;



	필드의 가공 처리
	---------------

	사원의 사번, 이름, 급여를 조회하는데 단, 급여는 100$를 추가하여 검색하시오.
	answer)	select empno, ename, sal, sal+100 from emp;

	
	필드에 alias 적용(필드명을 잘 써놓긴 했지만 더 잘 알아보기 위해서 별명이란걸 붙일 수 있다.)
		필드 as 별명
		
		필드 별명(as를 제거하고)

		ex)	select empno as 사번, ename, sal from emp;
			select empno as 사번, ename 사원명, sal from emp;
			select empno as 사번, ename "사원명", hiredate "입사 일자" from emp;

			sql에서는 모두 홑따옴표를 쓴다. 쌍따옴표는 아주 특별한 경우
			쌍따옴표는 띄어쓰기가 있을때 가능하게 해준다.


		중복된 값 제거

			distinct, distinct()
		---------------------------
		select job from emp;	검색을 해봤는데 중복된 것들이 나온다
		select distinct job from emp;	이렇게 작성하고 검색하면 중복된 것을 제거한다.



(3) 확장 문법

	1) 정렬 기능

		ORDER BY 필드명[,필드명,...] [ASC(기본값) | DESC]	(ASC= 오름차순, DESC= 내림차순)
						ASC는 기본값이므로 생략가능.

				필드명에 ,를 써서 여러개 필드를 1차, 2차, 3차 정렬을 할 수 있다.
	----------------------------------------------------------------------------------------------
	만일, 급여가 많은 순으로 사번, 이름, 급여를 조회하겠다고 하면.
	일단 항상 기본문법을 작성해라.
	select empno, ename, sal from emp;			-> 이것이 기본문법
	select empno, ename, sal from emp order by sal desc;	-> 정렬기능을 추가 내림차순으로(급여가 많은것부터니까)	
		

	또, 부서별로 급여가 적은순으로 이름, 급여, 부서코드를 조회해보아라.

	select ename, sal, deptno from emp; 				->기본문법
	select ename, sal, deptno from emp order by deptno;		->1차정렬 부서별로 정렬함.
	select ename, sal, deptno from emp order by deptno, sal asc;	->2차정렬 부서별정렬 후 급여 오름차순
	select ename, sal, deptno from emp order by deptno desc, sal asc;	*또한 부서는 내림 급여는 오름처럼 나눠서 정렬도 가능하다.


	2) 조건문(원하는 나의 코드를 볼 수 있도록 해준다. 이 기능이 없으면 1억개의 데이터를 다 보던가해야하니까..)

		WHERE 조건절 (= WHERE 필드명 연산자 값) *순서에 유의할 것. 필드명부터 처리해야한다.

		- 연산자
			기본연산자 : >, <, >=, <= =, <>, !=, ...

			논리연산자 : and, or, not
			
			SQL 연산자: between and, in, is null, like


			*like 연산자
				
				% : 0개 이상의 문자를 대체할 수 있다.
				
				_  : 1개의 문자를 대체한다.

				ex) beaut% : beaut, beauti, beauty, beaytiful,....(= beaut 를 포함한 모든 문자를 찾겠다)

				      beaut_  : beaut(찾을 수 없다 글자하나는 반드시 포함해야한다.)
					     beauty,....(찾을 수 있다)

		-----------------------------------------------------------------	

		급여가 3000$ 이상인 직원의 사번, 이름, 급여를 조회
		단, 급여가 많은 순으로 조회

		select empno, ename, sal from emp;			->기본문법
			where sal >= 3000;(조건문 급여가 이상 3천달러 (= where 필드명 연산자 값))

			*order by는 가장 마지막 문장에 써줘야 한다. 그리고 한줄로 다 작성하면 된다.

		select empno, ename, sal from emp;		->기본문법
			where sal >= 3000 order by sal desc;(조건문 급여가 이상 3천달러 (= where 필드명 연산자 값))


		Q)업무가 manager 인 사원의 이름, 부서, 업무를 조회하라.

		select ename, deptno, job from emp;
			where job = 'MANAGER';


		Q) 1982년 1월 1일 이후에 입사한 직원의 이름, 부서, 입사일자를 조회

		select ename, deptno, hiredate from emp where hiredate > '1982/1/1';

	
		
		Q) 부서가 20이고 업무가 analyst 인 직원의 이름, 부서, 입사일자를 조회하라.

		select ename, deptno, hiredate, from emp where deptno = 20 and job = 'ANALYST';


		Q) 급여가 1500 이상 2500 이하를 받는 직원의 이름, 부서, 업무, 급여를 조회하라.

		select ename, deptno, job, sal from emp where sal >= 1500 and sal <= 2500;

		아래와 같이 간단하게 바꿀 수도 있다.

		select ename, deptno, job, sal from emp where sal between 1500 and 2500;
		(*주의 between and 는 반드시 and 조건이여야하며 이상과 이하라는 범위를 가질 때 사용해야한다)


		Q) 업무가 clerk, salesman, analyst인 직원의 이름, 부서, 업무를 조회

		select ename, deptno, job from emp where job = 'CLERK' or job = 'SALESMAN' or job = 'ANALYST' order by deptno desc;
		
		위의 코드를 아래 처럼 간단히 바꿀 수 있다. in을 활용

		select ename, deptno, job from emp
			where job in('CLERK', 'SALESMAN', 'ANAYST');

		(주의사항 : in 은 반드시  "같다" 라는 조건 하에서 사용가능하다)


		Q)이름이 s로 시작하는 직원의 이름, 업무, 급여를 조회하라 

		select ename, job, sal from emp where ename like 'S%';

		Q)1981년에 입사한 직원의 이름, 업무, 입사일자를 조회

		select ename, job, hiredate from emp where hiredate like '81%';

		select ename, job, hiredate from emp where hiredate between '81/1/1' and '81/12/31';


		Q) 직원의 사번, 이름, 부서, 업무, 급여, 보너스를 조회
		select empno, ename, deptno, job, sal, comm from emp;

		위의 코드를 실행해보면 commision 에 0도 아닌 비어있는 것이 확인된다. 그것은 값이 null 이고 비어있다는 뜻.

		Q)커미션을 받지 못하는 직원의 이름, 부서, 업무, 급여, 보너스를 조회하라.

		select ename, deptno, sal, comm from emp where comm is null;

		select ename, deptno, sal, comm from emp where job = 'SALESMAN';

		select ename, deptno, sal, comm from emp where job != 'SALESMAN';

		select ename, deptno, sal, comm from emp where not(job = 'SALESMAN');

		Q) 커미션을 받는 직원의 이름, 부서, 업무, 급여, 보너스 조회
		select ename, deptno, job, sal, comm from emp
			where comm is not null;



6. Functions(함수)

(1) Single Row Functions	(하나의 레코드에서 사용하는 단일행 함수)

	1) 문자함수
		lower(),upper()		(대문자 소문자 바꿔주는 기능)
		substr()
		length()
		instr()
		ltrim, rtrim()
		translate(), replace()
		chr(), ascii()
		------------------------------------------------------
		Q)이름이 scott인 직원의 이름, 부서, 급여를 조회하려한다.
		단, 대소문자 구별없이 검색할 수 있도록 한다.

		select ename, deptno, sal from emp
			where ename = 'SCOTT';


		select ename, deptno, sal from emp
			where ename = upper('scott');


		select ename, deptno, sal from emp
			where upper(ename) = upper('scott');		-> 위의 코드보다 조금더 안전하다.


		다음의 주민번호에서 성별에 해당하는 것을 추출하여라.
		select '901225-1234567' from emp;	->emp 테이블의 데이터 개수인 14개의 데이터가 나온다..
		select '901225-1234567' from dual;

		select substr('901225-1234567', 8, 1) from dual;	왼쪽 8번째부터 한글자만 출력

		select substr('901225 - 1234567', 8) from dual;	왼쪽 8번째부터 끝까지 출력


		문자열의 길이
		select length('안녕하세요... sql입니다.') from dual;

		select hiredate, length(hiredate) from emp;

		문자열의 위치

		select instr('MILLER', 'L') from dual;		//L이 몇번째있는지 보여준다.
		select instr('MILLER', 'L', 1, 1) from dual;	//첫번째 L을 찾게 해준다.
		select instr('MILLER', 'L', 1, 2) from daul;	//두번째 L을 찾게 해준다.
		select instr('MILLER', 'K')from dual;

		
		공백 및 문자 제거

		select  ltrim('MILLER', 'M') from dual; 	-> 왼쪽에 M이 있으면 삭제해라.
		select ltrim('          MILLER') from dual;
		select rtrim('MILLER        ')from dual;
		select ltrim(rtrim('            MILLER               ')) from dual;


		문자열 재배치

		select translate('MILLER', 'L', '*') from dual; 	-> L을 *로 바꾸겠다. L 둘다 바뀜.
		select replace('MILLER', 'L', '*') from dual;	-> 결과는 위와 같은데 차이점이 뭘까?

		select translate(sal, '0123456789', '영일이삼사오육칠팔구')from emp;	-> 바뀐다.
		select translate(sal, '0123456789', '영일이삼사오육칠팔구')from emp; -> 바뀌지 않음.

		즉, translate는 바꿀 데이터의 갯수를 맞추고 하나하나의 데이터를 변경해준다.
		하지만 replace는 한덩어리를 바꾸게된다 즉 0123456789 이라는 하나의 데이터가 있으면
		영일이삼사오육칠팔구로 바꿔줄테지만 그러한 데이터는 없다.

		select translate('JACK and JUE', 'J', 'BL') from dual;	-> 결과는 Back and Bue, 한글자만 대응했다.	
		select replace('JACK and JUE', 'J', 'BL') from dual;	-> 결과는 Black and Blue


		아스키코드

		select chr(65), chr(97) from dual;
		select ascii('B'), ascii('b') from dual;


	2) 숫자함수

		round(), trunc(), floor(), ceil(), 	-> floor는 무조건 숫자를 내림, ceil은 무조건 올림
		mod()
		power()
		sign()
		--------------------------------------------------

		소수점 자리수
		select round(4567.678), round(4567.478) from dual;
		select round(4567.678), round(4567.478, 0) from dual;	->소수점을 기준으로 자리는 0 1 2 이다. 즉 4는 0 7은 1 8은 2이다.
		select round(4567.678, 1), round(4567.478, 2) from dual;
		select round(4567.678, -2), round(4567.478, 2) from dual;	-> 정수 자리의 반올림도 가능하다.

		select trunc(4567.678), trunc(4567.478) from dual;		-> trunc는 절삭
		select trunc(4567.678, 1), trunc(4567.478, 2) from dual;
		select trunc(4567.678, -1), trunc(4567.478, 2) from dual;

		select floor(4567.678), floor(4567.478) from dual;		-> 무조건 내림
		select ceil(4567.678), ceil(4567.478) from dual;		-> 무조건 올림
		select ceil(4567.678, 1), ceil(4567.478, 2) from dual;	-> 안된다. 오류 발생. 정수형만 취급한다.

		나머지
		select mod(10, 3) from dual;
		
		거듭제곱
		select power(2, 10) from dual;
		
		부호표시
		select sign(100), sign(-15), sign(0) from dual;



	3) 날짜함수

		sysdate			->  현재 시간과 날짜를 보여줌, 기본이라 편하게 쓰라고 괄호도 없음
		months_between()
		add_months()
		next_day()
		last_day()
		round(), trunc()
		---------------------------------
		select sysdate from dual;			-> 현재 날짜를 표시
		select sysdate+100 from dual;		-> 현재 날짜 + 100일 
		
		select months_between('2016/8/5', sysdate) from dual;	->현재날짜를 기준으로 8월5일까지 얼마나 남았는가?
		
		select add_months(sysdate, 6) from dual;	-> 현재 날짜를 기준으로 6개월 후가 언제임?

		select next_day('2016/1/17', '금') from dual;	-> 1월17일을 기준으로 다음번 금요일은 언제인가?

		select last_day(sysdate) from dual;		-> 그달의 마지막 날을 알려줌. 월을 지정할 수도 있음
		select last_day('2016/1/5') from dual;		-> 이렇게 월을 지정하면 그 달의 마지막 날을 알려줌.

		select round(sysdate) from dual;		-> 내일 날짜가 나와야지 반올림이니까
		select round('2016/9/23') from dual;		-> 에러발생 문자열이라서 반올림이 안된다. 캐스팅해줘야함.
		select round(to_date('2016/9/23')) from dual;	-> to_date 를 쓰면 날짜로 캐스팅된다.
		select round(to_date('2016/9/23'), 'MONTH') from dual;	-> 월을 기준으로 반올림함
		select round(to_date('2016/9/23'), 'YEAR') from dual;	-> 년을 기준으로 반올림함



	4) 변환함수

		cast()
		to_char()
		to_date()
		to_number()
		---------------------
		select ename, sal, to_char(sal) from emp;	-> 숫자를 문자열로 변환해준다. 이것을 어떻게 활용할 수 있는가? 아래처럼
			

		select ename, sal, to_char(sal, '$999,999') from emp;	-> $를 앞에 붙이고 3자리마다 ,를 붙인다.
		select ename, sal, to_char(sal, 'L999,999') from emp;	-> L을 붙이면 그 나라, 지역의 화폐를 보여준다.
		
			*여기서 오른쪽 정렬이 되는데 이는 숫자를 의미한다 to_char 를 썼다고 해서 문자로 된다기 보다,
			형식의 변화를 주는데 의미를 가진다.
		

		select to_char(sysdate, 'YYYY MM DD HH"시" MI"분" SS"초"') from dual;	-> 시간도 보여주면 한글표시는 쌍따옴표

	5) 기타

		nvl() : null value의 약자이며 일종의 조건문, 단일 조건문 null일 경우에만!
			ex) 만일 숫자 + null 의 답은? A. 답은 null이긴 하지만 계산이 안되서 null로 보여주는 것. null은 엄연히 값이 있는 데이터이긴하다.

			
		Q. 직원의 이름, 급여, 커미션, 총급여(급여+커미션)를 검색하라.
		A. select ename, sal, comm, sal+comm as "총급여" from emp;
		*이럴 때 nvl은 null값을 다른 값으로 바꿔주는 함수이다.
		select ename, sal, comm, sal+nvl(comm, 0) as "총급여" from emp;
		(	nvl(comm, 0) = 커미션 값이 null 일 경우 0으로 바꿔줘라	)

		-------------------------------------------------------------------------------------

		decode() : nvl 과는 다르게 다중 조건문, 반드시 "같다" 라는 조건만 가능하다. 크다 작다는 없음.

		select ename, decode(job, 'SALESMAN', '맞다', '아니다') from emp;
			(job 이라는 필드가 saleseman데이터와 true이면 맞다 false이면 아니다)

		자바로 보면,
		if(job.equals("SALESMAN"))
			sysout("맞다");
		else
			sysout("틀리다");

		
		다중 조건이라면,
		decode(필드명, 값, 참, 값, 참, 값, 참, 값, 참, 거짓);
		= 필드명이 다음 값과 같다면 참을 처리하고 그렇지 않고 그 다음값과 같다면 다음의 참을 처리하고
		이를 반복하다가 마지막 값과도 같다면 참을 처리하고 그마저도 아니면 거짓을 처리하라.

		-------------------------------------------------------------------------------------



		
	6) 정규표현식 함수 : 문자와 숫자, 특수문자를 포함한 하나의 덩어리 문장에 대한 규칙을 정하는 것.
			ex) 이메일처럼 email456 @ naver . com 처럼 앞에 문자 숫자 @ 문자숫자 점 문자숫자
				위처럼 일정 규칙을 갖는 것을 정규표현식 함수라고 한다.


		REGEX_이름()


(2) Aggregation Functions	(최소한 두개 이상의 레코드에서 사용하는 집합 함수)

	1) sum()		: 합계를 하기 위해서는 2개 이상의 레코드가 필요하니까

	avg(), max(), min(), count() : 이것들도 이러한 이유로 위와 같다.


	2) SELECT의 확장문법 3번째

		GROUP BY 필드명[, 필드명,...]

		HAVING 조건절

	----------------------------------------------------------------------------------

	Q.) 업무가 salesman 인 직원들의 급여평균, 최고액, 최저액, 합계를 조회하라.
	A.) select avg(sal), max(sal), min(sal), sum(sal) from emp where job = 'SALESMAN';

	Q.)직원이 총 몇명인가?
	A.) select * from emp;
	A.) select count(empno) from emp;	-> 이때의 count는 괄호 안 필드의 레코드의 갯수를 계산한다.
					-> count는 null 값을 제외한 필드의 레코드 갯수를 계산한다. comm은 4개가 나온다.

	Q.) 부서별로 급여 평균, 최고 급여, 최저 급여, 급여 합계를 조회하라.
	A.) select distinct deptno from emp;	-> 중복값을 제외하여 어떤 부서들이 있는지 확인하자.
	A.) select avg(sal), max(Sal), min(sal), sum(sal) from emp where deptno=10;	
	     select avg(sal), max(Sal), min(sal), sum(sal) from emp where deptno=20;
	     select avg(sal), max(Sal), min(sal), sum(sal) from emp where deptno=30;

		위의 명령어는 너무 불편하다. 이것을 한번에 해결할 수 있는 방법은 무엇인가?

	A.) select deptno, avg(sal), max(Sal), min(sal), sum(sal) from emp group by deptno;	-> 그룹별로 묶어서 한번에 보이도록하라.
		
		위의 group by 는 집합함수와 함께 사용되어야한다.


	Q.) 부서별 직원수를 조회
	A.) select deptno, count(detpno) from emp group by deptno;

	Q.) 부서별 급여평균, 최고급여를 조회하는데, 단 급여평균이 높은 순으로 조회하시오.
	A.) select deptno, avg(sal), max(sal) from emp group by deptno order by avg(sal) desc;

	*note 실행순서 및 컴파일(그림참조 DB-groupby순서)

	select deptno, avg(sal), max(sal) from emp 
	group by deptno 
	order by avg(sal) desc;

	*주의할 점
		
	select deptno, avg(sal), max(sal) from emp;	
	-> deptno 는 14개로 출력되고 avg 와 max 는 1개로 표현되니까 처리가 안된다.

	select deptno, avg(sal), max(sal) from emp group by deptno;	
	-> group by 를 쓰게 되면 3개의 부서로 나뉜 부서는 3개로 출력되고 avg 와 max 도 3개로 출력된다.

	select deptno, job, avg(sal), max(sal) from emp group by deptno, job;
	-> 1차 그룹, 2차 그룹으로 나눌 수 있다. 근데 보기가 어지러우니 order by 를 해주자.

	select deptno, job, avg(sal), max(sal) from emp group by deptno, job order by deptno, job;	
	-> 부서별로 묶고 그 안에서 업무별로 묶었다. 급여는 마지막 정렬인 업무별로 적용되었다.

	Q.) 전체 급여의 합계가 5000을 초과하는 업무에 대해 급여 합계 조회
	A.) select job, avg(sal), max(sal), sum(sal) from emp group by job having sum(sal) > 5000;

	-> 조건문인 where는 그룹으로 정렬이 되고 난 이후에 적용되야한다. 그렇지 않으면 전체 급여로 적용되니까.
	-> 그런데 where는 group by 뒤에 쓸 수가 없다. 그래서 group by 뒤에서 쓰여질 조건문이 따로 있다. HAVING

	Q.) 전체 급여의 합계가 5000을 초과하는 업무에 대해 급여 합계를 조회하시오. 단 SALESMAN은 제외하시오.
	A.) select job, sum(sal) from emp group by job having job != 'SALESMAN' and sum(sal) > 5000;

		-> 그룹으로 묶고 salesman 을 걸러낸 경우

	     select job, sum(sal) from emp where job != 'SALESMAN' group by job having sum(sal) > 5000;
		
		-> 먼저 salesman 을 걸러내고 그룹으로 묶는 경우 어떤 것이 성능이 빠른가? 일반적으로는 후자.


(3) Analystic Functions	(분석 함수)

	-> 이건 따로 하지 않겠다.


7. DML

(1) insert, update, delete
(2) 실습

	1) 계정을 새로 작성 : usertest1
	2) 테이블 작성
		CREATE TABLE tbltest(
			id		number,
			name		varchar2(10),
			hiredate		date
		);

	3) insert 테스트

		INSERT INTO 테이블명(필드명,...) VALUES(값, ...)	
		
		-> 어느 테이블의 필드에 값을 넣겠다. 형식을 잘 지켜주면 된다.

		1. insert into tbltest(id, name, hiredate) values(1, '홍길동', sysdate);
		2. insert into tbltest(id, name) values(2, '임꺽정');

		3. insert into tbltest values(3, '김유신', '2016/2/6');
		-> 항목을 생략할 수도 있지만 2번처럼 누락되는 데이터가 있으면 안된다.


	4) update 테스트

		UPDATE 테이블명 SET 필드명 = 값 WHERE 조건절
		-> 수정해라 테이블 내 필드의 값을 

		update tbltest
		set hiredate = sysdate-10, name = '홍길순'
		where id=1;

		-> 여러개를 바꿀 때는 ,를 찍고 추가하면 된다.


	5) delete 테스트

		DELETE FROM 테이블명;
		-> 이렇게만 쓰면 테이블 내의 데이터를 모두 지운다. 테이블을 지우는 것은 DROP
		-> 모든 데이터를 지우고 싶지 않다면 역시 조건절을 달아준다.

		DELETE FROM 테이블명 WHERE 조건문;

		delete from tbltest where id=2;
		-> id 가 2에 해당하는 데이터를 지운다.


	6) drop 테스트

		테이블을 지우려면 drop table 테이블명;
		
		-> 실수로 지운거면 flashback table 테이블명 to before drop; 이렇게 써주면 복구된다.

		-> show recyclebin; 을 입력하면 휴지통 내에 drop 된 테이블을 볼 수 있으며
		-> purge recyclebin; 을 입력하면 휴지통을 지우고 더이상 복구는 불가능하다.
		


8. SUBQUERY(= 중첩된 QUERY)

(1) 다른 query문에 포함된 query문을 의미한다.
(2) 반드시 ()를 사용해야한다.
(3) 연산자의 오른쪽에 사용해야한다.
(4) order by를 사용할 수 없다.	-> 내부의 쿼리가 먼저 실행되기 때문에 뒤에 ORDER BY를 사용할 수 없다.
(5) 종류
	1) 연관 서브쿼리		
		-> 메인쿼리와 서브쿼리가 서로 연관되어있다라는 것을 의미한다.
		-> 진행순서 1. 메인에서 먼저 처리되고 2. 내부쿼리가 실행되고 3. 다시 메인쿼리로 넘어감

	2) 비연관 서브쿼리		
		-> 메인쿼리와 서브쿼리가 서로 연관되어있지 않다.
		-> 진행순서 1. 내부쿼리가 실행되고 2. 메인쿼리가 실행된다.
		-> 한번의 서브쿼리로 처리가 가능하면 비연관으로 분류할 수 있다. 그게 아니면 연관 서브쿼리
(6) 유형
	1) 단일행	-> 서브쿼리의 결과값(레코드)이 하나의 값일 때, 그것을 단일행이라고 한다.
	2) 다중행	-> 서브쿼리의 결과값이 여러개일 때, 그것을 다중행이라 한다.
	3) 다중열	-> 

(7) 연산자

	1) 단일행
		>, <, >=, <=, =, <>, ...(단일행에서만 사용된다)
	2) 다중행
		in(=) any (부호와 함께 써야한다. any는 or와 비슷한 기능이다.), all(= and와 비슷한기능이다), exists, not, ....
-----------------------------------------
Q.) scott 의 급여보다 더 많이 받는 직원의 이름, 업무, 급여를 조회하라.
A.) select ename, job, sal from emp where ename = 'SCOTT';
     select ename, job, sal from emp where sal > 3000;

	-> 위 처럼 두번을 나눠서 써야 검색이 완료된다. 이것은 너무 불편하다. 중첩 쿼리를 쓰면 편하다.

	select ename, job, sal from emp where sal>(select sal from emp where ename = 'SCOTT');

	-> 이렇게 하면 한번에 처리가능하다. 괄호 밖의 쿼리가 메인쿼리이며 괄호안은 서브쿼리고 연산자 오른쪽에 서브쿼리가 위치한다.



Q.) 사번이 7521의 업무와 같고, 급여가 7934보다 많은 직원의 사번, 이름, 업무, 급여를 조회하시오.

A.) select empno, ename, job, sal from emp;
     select empno, ename, job, sal from emp where sal > 1300;
     select empno, ename, job, sal from emp where sal > 1300 and job = 'SALESMAN';
     select empno, ename, job, sal from emp where job = 'SALESMAN' and sal > 1300;

	정답)
     select job from emp where empno = 7521;	-> 1번
     select sal from emp where empno = 7934;	-> 2번
     select empno, ename, job, sal from emp where job =(1번) and sal > (2번);
     select empno, ename, job, sal from emp where job =(select job from emp where empno = 7521) and sal > (select sal from emp where empno = 7934);


Q.) 업무중에서 가장 적은 평균급여를 받는 업무와 평균 급여를 조회하라.
A.)	select avg(sal), job from emp group by job;	-> 평균과 업무 조회 업무별로
	select min(avg(sal)) from emp group by job;	-> 가장 적은 평균급여 업무별로

     select avg(sal), job from emp group by job having avg(sal) = (select min(avg(sal)) from emp group by job);

     
------------------------------
서브쿼리 종류, 유형, 연산자 이후
------------------------------

Q.) 업무별로 최소 급여를 받는 직원의 사번, 이름, 업무, 급여, 부서번호를 조회하시오
A.) 	select job, min(sal) from emp group by job;

	select empno, ename, job, sal, deptno from emp where sal = 800 or sal = 1250 or sal = 5000 or sal = 2450 or sal = 3000;

	select ename, empno, job, sal, deptno from emp where sal in (select min(sal) from emp group by job);



Q.) 업무별로 최소급여보다 많은 급여를 받는 직원의 사번, 이름, 업무, 급여, 부서번호 조회하라.
A.) 	
	select empno, ename, job, sal, deptno

	select empno, ename, job, sal, deptno from emp where sal > 800 or sal > 1250 or sal > 5000 or sal > 2450 or sal > 3000;

	select ename, empno, job, sal, deptno from emp where sal > any (select min(sal) from emp group by job);



Q.) 업무별 최대 급여이상 받는 직원의 사번, 이름, 업무,급여 부서번호를 조회.
A.)	select max(sal) from emp group by job;
	
	select empno, ename, job, sal, deptno from emp where sal >= 800 or sal >= 1250 or sal >= 5000 or sal >= 2450 or sal >= 3000;

	select ename, empno, job, sal, deptno from emp where sal >= all (select max(sal) from emp group by job);



Q.) 적어도 한명의 직원으로부터 보고를 받을 수 있는 직원의 이름, 업무, 입사일자, 급여를 조회
A.)	select distinct mgr from emp;
	select 
	select ename, job, hiredate, sal from emp where empno in (select distinct mgr from emp);


	연관커리로 해보자. (복잡함)
	select empno, ename, job, hiredate from emp e <- e는 구별하기 위한 내가 지은 별명
	where  exists(select * from emp where e.empno=mgr);	<- 비연관과는 다르게 괄호안에만 실행하면 실행되지 않는다.



다중열
--------------

(1) 사번이 7934인 직원의 급여를 1500, 커미션을 300으로 수정

select empno, sal, comm from emp where empno = 7934;


     EMPNO        SAL       COMM
---------- ---------- ----------
      7934       1300


update emp set sal=1500, comm=300 where empno=7934;


  EMPNO        SAL       COMM
---------- ---------- ----------
      7934       1500        300



(2) 급여와 커미션이 30번 부서에 있는 직원의 급여와 커미션이 같은 직원에 대해 사번, 이름, 부서번호, 급여, 커미션을 조회하시오.

select deptno, ename, sal, comm from emp where deptno = 30;


select ename, empno, deptno, sal, comm from emp -> 여기까진 기본
where sal in (select sal from emp where deptno=30) and comm in (select comm from emp where deptno=30);	-> 급여와 커미션을 비교해야돼.

select ename, empno, deptno, sal, comm from emp where sal in (select sal from emp where deptno=30) and comm in (select comm from emp where deptno=30);

-> 그런데 결과가 sal 따로 comm 따로다. 그래서 miller가 검색이 되는데 밀러의 1500 / 300 에 대한 급여 커미션은 없다.
	이를 해결하기 위해서 다중열이 존재한다.


select ename, empno, deptno, sal, comm from emp where (sal, comm) in (select sal, comm from emp where deptno=30);









================================================================================================================================================
9. JOIN

: 전체 데이터가 하나의 테이블에 있지 않고 분산되어 있는 데이터 테이블이 있는데, 이 테이블을 병합하여 하나의 결과로 볼 수 있도록 하는 것을 Join이라 한다.


(1) 여러 개의 테이블을 병합하여 하나의 결과를 도출하기 위한 방법
(2) 종류
	1) Cartesian Join(데카르트 곱)
	2) Equi Join
		1) 공통 필드의 레코드를 가져오는 방법
		2) Inner Join(Natural Join)
	3) Non Equi Join
		1) 공통 필드가 없을 경우에 사용

	4) Outer Join
		1) Extended Join(Inner Join + 공통되지 않은 레코드)
		2) 종류
			- Left Outer Join
			- Right Outer Join
			- Full Outer Join

	5) Self Join

		1) 서로 같은 테이블을 조인



(3) 실습
	1) usertest1으로 접속
	2) 테이블 생성
		
		CREATE TABLE tblA(
			id	number,
			value	number
		);

		CREATE TABLE tblB(
			id	number,
			value	number
		);


		CREATE TABLE tblC(
			id	number,
			calue	number
		);



		insert into tblA values(1, 10);
		insert into tblA values(2, 20);
		insert into tblA values(3, 30);
		insert into tblA values(5, 50);
		insert into tblA values(7, 70);

		insert into tblB values(1, 10);
		insert into tblB values(2, 20);
		insert into tblB values(4, 40);
		insert into tblB values(5, 50);
		insert into tblB values(8, 80);

		insert into tblC values(1, 10);
		insert into tblC values(2, 20);
		insert into tblC values(7, 70);
		insert into tblC values(8, 80);
		insert into tblC values(9, 90);



	3) Inner Join

		select id, value
		from tblA inner join tblB	<- 두테이블 사이에 inner join 하게 되면 두 테이블을 병합한다.
		on tblA.id = tblB.id;		<- 애매하다고 나옴.
		
		 select tblA.id, tblA.value
		from tblA inner join tblB
		on tblA.id = tblB.id;

		 select tblA.id, tblA.value
		from tblA, tblB
		where tblA.id = tblB.id;	<- PL / SQL 방식 inner join 을 없애고 on 대신 where을 쓴다. 조건절을 제외하고 명령어를 입력하면 모두 대응해서 값을 출력한다.
		


		 select a.id, a.value
		from tblA a inner join tblB b
		on a.id = b.id;		<- from 문장 뒤에 별명을 쓸 수 있다. 그러면 나머지 이름 테이블에 별명을 써줘야한다.


Q) 직원의 사번, 이름, 업무, 부서번호, 부서명을 조회하라.

A)select empno, ename, job, emp.deptno, dname from emp inner join dept on emp.deptno = dept.deptno;

Q) SALESMAN에 대해서 사번, 이름, 업무, 부서명을 조회하라.

select empno, ename, job, dname 
from emp inner join dept 
on emp.deptno =  dept.deptno and job='SALESMAN';


select empno, ename, job, dname 
from emp inner join dept 
on emp.deptno =  dept.deptno
where job = 'SALESMAN'		<- where 조건을 쓸 수도 있다. 그런데 join 하면서 조건을 처리하는방법 (and) join 이후 where 쓸지 결과가 다를 수도 있다.


Q) Newyork에서 근무하는 직원의 사번, 이름, 업무, 부서명을 조회하라.

select empno, ename, job, dname
from emp inner join dept
on emp.deptno = dept.deptno
where loc = 'NEW YORK';









	4) Outer Join

		select tblA.id, tblA.value, tblB.id, tblB.value
		from tblA left outer join tblB
		on tblA.id = tblB.id;

		select tblA.id, tblA.value, tblB.id, tblB.value
		from tblA right outer join tblB
		on tblA.id = tblB.id;


		select tblA.id, tblA.value, tblB.id, tblB.value
		from tblA full outer join tblB
		on tblA.id = tblB.id;


		--------------------------------------
		PL / SQL 방식

		select tblA.id, tblA.value, tblB.id, tblB.value
		from tblA, tblB
		where tblA.id = tblB.id(+);			<- left


		select tblA.id, tblA.value, tblB.id, tblB.value
		from tblA, tblB
		where tblA.id(+) = tblB.id;			<- right



		select tblA.id, tblA.value, tblB.id, tblB.value
		from tblA, tblB
		where tblA.id(+) = tblB.id(+);			<- full outer 안된다. 표준 sql 에서만 지원함.


		Q) 이름, 급여, 부서명, 근무지를 조회하시오.
		단, 부서명과 근무지는 모두 출력할 수 있도록 하시오.


		select ename, sal, dname, loc from emp full outer join dept
		on emp.deptno = dept.deptno;



	5) Non equi join

		Q)직원들의 급여에 대한 등급을 조회하라.

		select ename, job, sal, grade, losal, hisal
		from emp inner join salgrade
		on sal>=losal and sal<=hisal;			<- equi join 과 같이 inner join을 사용하되, 같다라는 의미가 아닌 범위를 주면 non equi join 이다.



	6) 3개의 테이블을 조인하는 방법


		select a.id, a.value
		from tblA a inner join tblB b
		on a.id=b.id
		inner join tblC c
		on b.id=c.id;
		
		//두개를 먼저 조인하고 조건까지 써준 뒤에 또 다시 이너 조인,
		나머지 하나를 넣어주고 조건을 넣어주면된다. 이것은 표준 sql 방식이다.

		--------------
		PL / SQL 방식
		--------------
		

		select a.id, a.value
		from tblA a, tblB b, tblC c
		where a.id=b.id and b.id=c.id;

		//PL SQL 방식은 from 뒤에 콤마로 구성된 3개의 테이블을 연속적으로 작성할 수 있다.


	7) Self Join

		직원의 사번, 이름, 업무, 관리자, 관리자 이름을 조회하시오.
		
		select e1.empno, e1.ename, e1.job, e1.mgr, e2.ename "관리자이름"
		from emp e1 inner join emp e2
		on e1.mgr = e2.empno;

		//하나의 테이블을 복제하여 사용하는 것으로 같은 테이블을 사용하므로
		별명을 구분지어주도록 한다. 1번테이블에서 얻을 수 있는 것에 대해서 1번을 기재해주고
		필요한 정보에 대해서 2번 테이블 주소를 적어준다. 조건에는 연결될 수 있는 것을 적어준다.


	8) SET 연산자

		- UNION		: 중복을 뺀 합집합
		- UNION ALL	: 중복을 모두 포함한 합집합
		- INTERSECT	: 교집합
		- MINUS		: 차집합

		-------------------------------------------

		select deptno from emp
		union			
		select deptno from dept;

		// 위의 두 테이블을 실행하고나서 합치겠다(union)



		select deptno from emp
		union all
		select deptno from dept;

		select deptno from emp
		intersect
		select deptno from dept;

		select deptno from emp
		minus
		select deptno from dept;

		select deptno from dept
		minus
		select deptno from emp;




10. Transaction(DB 안에서 사용되는 작업단위)

	"All Or Nothing"	-> 일처리를 완벽히하려면 하고 아니면 하지말고. 어중간하게 하지마라.

			ex) 금융권에서 계좌이체를 하는데 중간에 작업이 중단되서 금액이 공중분해되면 안된다. 
			어중간하게 끝내지마라. 아니면 아예 처음 상태로 돌아가던가.
			트랜젝션 로그를 활용해서 다시 원래대로 돌아갈 수 있다.
			마찬가지로 DB에도 위와 같은 로그가 저장되는데 이것은 데이터로그이다.



(1) 로그에는 DML만 기록된다.	(*DML : insert, update, delete)

(2) commit, rollback		commit : 일을 완전히 완료했다. 더이상 되돌릴 수 없다.
				rollback: 발자취를 살펴보고 뒤로 돌아가겠다.

		
	작업방법: 하나의 작업을 하고 난 뒤 빈 커서에서 rollback 이나 commit 을 입력하면 된다.


(3) 동기화

	명령프롬프트 두개를 띄워놓고 확인해보면 알 수있다.
	commit 을 하지 않고 다른 창에서 확인해보면 변경된 것이 확인되지 않는다.




11. Data Integrity(데이터 무결성)

: 본인이 노력해서 막을 수 있는 말도 안되는 데이터를 막아내겠다.
	ex) 나이를 입력하시오. 1000살 (X) 이런 데이터는 막겠다.
  그 중 가장 기본이 되는 것은 중복된 데이터를 없게하는 것이다. 중복된 데이터로 인한 연쇄적인 문제를 예방하고자 한다.

(1) what? (무엇을 지킬 것인가?), how?(어떻게 지킬 것인가?)

	1) 실체(Entity) 무결성	: 여기서 entity 는 테이블 또는 객체(object가 아닌 entity)라 지칭한다.
				: 목표는 무엇인가? 실체를 지켜야한다.
				

		- 중복된 데이터 방지	: 목표
		- Primary Key, Unique 	: 이 두가지가 중복 방지를 위한 도구, 전문용어로 '제약(=Constraint)'


	2) 영역(Domain) 무결성		: 두번째 목표는 무엇인가? 영역을 지켜야한다.
					: ex) 나는 20살인데 25살로 적었어. 이것은 못막는다. 
					하지만 20살이 200살로 적었어. 이것은 범위(영역)를 지정해주면 지킬 수 있다.



		- 범위			: 목표
		- Check			: 범위를 지정하기 위한 도구


	3) 참조(Reference) 무결성(그림참조)	: 세번째 목표


		- 참조			: 그림파일 DB-참조무결성 참고할 것.
		- Foreign Key



	*note : 위의 무기(도구)들은 테이블을 구성하는 필드(컬럼)와 레코드 중 필드에게 부여된다.
		
		ex) Primarykey를 사번에 주면 중복된 사번은 들어갈 수 없다. 그런데 이 무기는 아무한테나 줄 수 없다.
			이름은 동명이인이 많기 때문에 중복을 허용하지 않는 필드를 먼저 찾아야한다.
			아래 (2) 컬럼의 속성에서 확인하자.


(2) 컬럼의 속성(특성)

	1) NN(Not Null) 속성	: 원래 컬럼은 null값을 허용하는데, NN은 null값을 허용하지 않는다.

		-  Primary Key, not null	: NN(Not Null) 이라는 속성을 지켜주기 위한 무기, 
					not null 을 입력하면 반드시 값을 입력해야한다.
					참고로 not null 은 테이블이 가지는 고유 기능이지 무기는 아니다.


	2) ND(No Duplicate) 속성	: 컬럼은 중복을 허용하는 특성을 갖는데, ND는 중복되지 않게 하겠다.

		- Primary Key, Unique

	3) NC(No Change) 속성	: 컬름은 변경을 가능하도록 하는 특성을 갖는데, NC는 변경을 불가한다.
		
		- Foreign Key




(3) Primary Key
	
	1) 하나의 테이블에 단 한개만 설정 가능
	2) 여러 개의 컬럼을 묶어서 설정이 가능하다.(따로 분리해서 (id, name))
----------------------------------------------

1) usertest1 으로 접속
2) 테이블 작성
	CREATE TABLE tblexam(
		id	numberl,
		name	varchar2(10)
	);
	//이렇게 생성하면 null 값을 포함하고 있는 것으로 데이터를 입력하지 않아도 null값으로 저장하기 때문에 문제가 없다.	

	CREATE TABLE tblexam(
		id	number		not null,
		name	varchar2(10)	null
	);
	//하지만 이렇게 생성하면 반드시 값을 입력해줘야한다.

	INSERT INTO tblexam(name) VALUES('홍길동');
	//이렇게 입력하여 데이터를 넣어보자 저장이되는가? null 값을 입력하라고 나온다.


	*null 값이야 입력해주면 되니까, ND를 써보면 중복값을 피해줄까? 해보자.

	INSERT INTO tblexam(id, name) VALUES(1, '홍길동');
	INSERT INTO tblexam(id, name) VALUES(1, '홍길동');
	INSERT INTO tblexam(id, name) VALUES(1, '홍길동');
	// 3개의 중복된 데이터가 저장된다.

	기존의 테이블을 수정하는 것이니까 alter를 써준다. (원래 테이블을 만들때 중복값을 없애는 기본키를 넣어줘야한다)

	ALTER TABLE tblexam ADD CONSTRAINTS pk_id PRIMARY KEY(id);
	//수정하게다 테이블인 tblexam을 어떻게? ADD 추가할거야 constraints를 pk_id 라는 이름으로 어떤무기를 장착해서? primary key를 id에 넣어서;

	//중복된 하나의 데이터만을 지울 수 없다. 전체를 다지워야한다 그래서 문제가 되는거다. 일단 지운다.
	delete from tblexam;

	//그리고 위의 alter 명령어를 입력하면 변경이 되었다는 문구를 확인할 수 있다.
	//그리고 다시 중복데이터를 저장해보려고하면 위배된다는 메시지를 확인할 수 있다.

	//테이블을 지우고 primary가 중복말고도 null값을 막아주는지 테스트를 하기 위해 다시 만들자.
	CREATE TABLE tblexam(
		id	number		null,
		name	varchar2(10)	null
	);
	// null 값을 허용해줬다. 그래도 primary key가 막아줄까? 막아준다.

	*note DD(=data dictionary 데이터 사전)
	
	DD를 활용해보자.
	desc user_constraints
	//user_constraints 에 뭐가 있는지 먼저 확인

	select constraint_name, table_name from user_constraints;
	//조회해보면 제약이 걸려있는 이름과 테이블 이름을 확인할 수 있다.

	ALTER TABLE tblexam DROP CONSTRAINT pk_id;
	//수정하겠다 테이블 tblexam을 삭제하겠다 constraint 제약을 pk_id에;

	select constraint_name, table_name from user_constraints;
	//다시 제약이 걸렸는지 조회해보면 없다.

	//이 모든 기본키를 테이블을 생성할 때 만들어보자. 일단 지우자
	DROP TABLE tblexam;

	CREATE TABLE tblexam(
		id	number		primary key,
		name	varchar2(10)	null
	);

	//id라는 필드에 기본키를 설정하겠다. 가장 간단하지만 이름을 따로 주지않는 것은 
	가장 비추천하는 방식이다. 왜냐면 제약명을 시스템이 스스로 만든다. 그래서 식별이 어렵다.

	//다시 테이블을 지우고 다시 만들어보자.

		CREATE TABLE tblexam(
		id	number		constraints pk_id primary key,
		name	varchar2(10)	null
	);
	
	//constraints 제약을 걸겠다 pk_id 라는 이름으로 primary key 무기는 이것이다. 이름으로 분간할 수 있게 된다.
	//근데 이것보다도 더 추천하는 방식이 있기는 하다.

			CREATE TABLE tblexam(
		id	number		,
		name	varchar2(10)	null
		constraints pk_id primary key(id)
	);

	//별도로 아래에 넣어주는 것을 더 추천하다. 대신 옆에 어디에 저장할지 지정해줘야한다. 이것이 왜 좋은가?
	DB-constraint 그림파일을 참조하도록 한다. 중요 !


(4) Unique
	1) 하나의 테이블에 여러 개 설정 가능
	2) 중복 방지만 가능하다 (null값 방지는 불가능)

----------------------------------------------------------------
//테스트를 위해 기존 테이블을 일단 삭제하고 다시 만든다.

CREATE TABLE tblexam(
	id	number		constraints uk_id unique,
	name 	varchar2(10)
);
//위 처럼해도 되고

CREATE TABLE tblexam(
	id	number		,
	name 	varchar2(10),
	constraints uk_id unique(id)
);
//이렇게 해도된다. 이 아이도 묶을 수 있다.

	INSERT INTO tblexam(id, name) VALUES(1, '홍길동');
	INSERT INTO tblexam(id, name) VALUES(1, '홍길동');

//중복을 막아주는지 넣어보실까? 안들어가네

	INSERT INTO tblexam(name) VALUES('홍길동');

//널값도 막아주려나? 넣어보자. 들어간다. 널값을 막아주지는 않는다.
//그런데 신기한 것은 오라클은 null 값끼리도 같다고 보지 않는다. 그래서 위의 삽입구를 넣으면 또 들어간다.
//널값이 달라서 들어가는 것인데 마치 중복을 방지 해주지 않는 것처럼 보이기도 한다.
//primary key 는 두가지의 무기를 합친 것이다. not null + unique = primary key


------------------------------------------------------------------------------------------------

필드	수정

ALTER TABLE tblexam MODIFY id number(4);
//수정이되는가? 문법은 맞다. 그런데 안된다. 왜? 최초에 생성될 때 가장 큰 값으로 생성된다. 
게다가 데이터가 있기 때문에 큰 것을 작게 줄일 수가 없다. 그렇다면 글씨 크기를 늘리는 것은 가능한가? 해보자

ALTER TABLE tblexam MODIFY name varchar2(20);
//글씨를 늘리는 것은 가능하다. 작은 것에서 크게 늘리는 것이므로
desc tblexam; 확인해보면 varchar2(20)으로 늘어난 것을 확인할 수 있다.

필드	추가

ALTER TABLE tblexam ADD zipcode char(7);
//varchar는 가변길이 문자열을, char는 고정길이 문자열을 취급한다.
//다시 말해 varchar는 20으로 지정해도 3글자의 글자를 저장하면 3글자에 해당하는 메모리만 할당한다.
//char 는 저장하는 문자의 크기가 2나 3이여도 처음에 7로 지정했다면 7에 대한 메모리를 할당한다.
//그렇다면 varchar 가 좋은가? 그렇지만은 않다. 성능면에서는 char가 더 좋기 때문이다.

DESC tblexam;

필드	삭제

ALTER TABLE tblexam DROP COLUMN id;



---------------------------------------------------------------------------------------------------

(5) DEFAULT	: 얘는 null 값을 막아준다. 사고가 터질 때 막아주는게 아니고, 사전에 방지한다. 
		  아예 null값 자체가 생기지 않도록 미연에 방지한다.


//일단 테이블을 삭제하고 새로만들자.
drop table tblexam;

CREATE TABLE tblexam(
	id	number(3),
	name	varchar2(10),
	point	number(3, 2)
);
//number는 정수자리 수와 실수자리 수를 사용할 수 있다.(3, 2)

CREATE TABLE tblexam(
	id	number(3)	default 0,
	name	varchar2(10),
	point	number(3, 2)
);

//그런데 여기에 default 0 을 넣어주면, 아예 널값이 발생하지 않도록 한다.
// id를 빼고 나머지만 입력해보자.

INSERT INTO tblexam(name, point) VALUES('홍길동', 3.4);
// 확인해보면 id에는 기본적으로 0이 들어가있음이 확인된다.

Q)필드 수정(name필드에 기본값으로 '무명씨'라는 값이 들어갈 수 있도록 설정하라.
A)alter table tblexam modify name varchar2(10) default '무명씨';
INSERT INTO tblexam(point) VALUES(3.5);

*note
default는 제약이 아니기때문에 constraint에 조회가 되지 않는다.

(6) SEQUENCE	: 얘는 null과 중복을 방지한다. 제약이 아니기 때문에 예방하는 차원의 도구이다.
		  게다가 테이블에 생성되는 것이 아니고 별도로 만들어지기 때문에 가져다 쓸 수도 있다.

	1) 자동으로 카운팅하여 일련번호를 리턴함.

--------------------------------------------------------------

//일단 시퀀스를 만든다.
CREATE SEQUENCE seq_num;

INSERT INTO tblexam(id, point) VALUES(seq_num.nextVal, 3.14);
// 시퀀스는 카운팅을 시스템에서 해주기 때문에 위에서처럼 적어줄 수 있다. 4개를 입력하고 조회해보자.

        ID NAME            POINT
---------- ---------- ----------
         0 홍길동            3.4
         0 1                    3.5
         1 무명씨            3.5
         0 무명씨            3.5
         1 무명씨           3.14
         2 무명씨           3.14
         3 무명씨           3.14
         4 무명씨           3.14

//이렇게 확인된다.
//오라클 create sequence 의 로직을 해보자. 일단 시퀀스를 지우고 다시 만들자.


drop sequence seq_num;

CREATE SEQUENCE seq_num INCREMENT BY 10 START WITH 50;
//10 단위로 증가하며 50부터 시작한다.
INSERT INTO tblexam(id, point) VALUES(seq_num.nextVal, 3.14);
//위의 값을 4개정도 입력하여 추가하면, 

        ID NAME            POINT
---------- ---------- ----------
         0 홍길동            3.4
         0 1                 3.5
         1 무명씨            3.5
         0 무명씨            3.5
         1 무명씨           3.14
         2 무명씨           3.14
         3 무명씨           3.14
         4 무명씨           3.14
        50 무명씨           3.14
        60 무명씨           3.14
        70 무명씨           3.14

        ID NAME            POINT
---------- ---------- ----------
        80 무명씨           3.14

//위와 같이 확인된다.

-------------------------------------------------------------------------------------

(7) CHECK	: 영역 무결성을 지키기 위한 무기(도구)

//이전에 만든 테이블을 일단 삭제한다.

drop table tblexam;

CREATE TABLE tblexam(
	id	number,
	name	varchar2(10),
	city	varchar2(10)
	constraints ck_city check(city='서울' or city='경기' or city='인천')
);
//check는 괄호가 사용되며 괄호 내에 조건식이 쓰인다.

insert into tblexam(id, name, city) values(1, '김동유', '서울');

Q)필드 추가(age number(2)) 나이를 19~60까지만 입력받을 수 있도록 설정


ALTER TABLE tblexam ADD age number(2) constraints ck_age check(age>=19 and age<=60);
ALTER TABLE tblexam ADD age number(2) constraints ck_age check(age between 19 and 60);


insert into tblexam(id, name, city, age) values(2, '이재승', '경기', 28);
insert into tblexam(id, name, city, age) values(3, '김상덕', '인천', 60);
insert into tblexam(id, name, city, age) values(4, '정범구', '경기', 19);



(8) Foreign Key

CREATE TABLE tblDept(
	deptno	char(3),
	dname	varchar2(10)
);


INSERT INTO tblDept VALUES('100', '영업부');
INSERT INTO tblDept VALUES('200', '마케팅부');


CREATE TABLE tblEmp(
	empno	number,
	ename	varchar2(10),
	hiredate	date,
	deptno	char(3)
);

INSERT INTO tblEmp VALUES(1, '홍길동', sysdate, '100');
INSERT INTO tblEmp VALUES(2, '임꺽정', sysdate, '300');
//부서번호 100은 들어가지만 300은 ? 들어가기는 하지만 잘못된 데이터이다. 
그러니 dept에 참조하여 올바른 값인지 물어봐야한다. 일단 테이블을 지우고 처음부터 참조관계를 맺어작성해보자.

delete from tblEmp where empno=2;

ALTER TABLE tblEmp ADD CONSTRAINTS fk_tblDept_tblEmp_deptno
FOREIGN KEY(deptno) REFERENCES tblDept(deptno);

//부모자식순서로 써준다. 근데 위의 명령어는 실행이 안돼. 
왜냐면 참조를 당하는 테이블의 필드는 안전장치를 달아줘야한다.
기본키나 유니크로 안전장치를 걸어줘야한다.

tblDept의 deptno에 기본키 추가.

ALTER TABLE tblDept ADD CONSTRAINTS pk_deptno PRIMARY KEY(deptno);


UPDATE tblDept set deptno='101' where deptno='100';
//무결성 제약 조건에 위배됨. 자식 레코드 발견
Drop TABLE tbldept;
//외래키에 의해 참조되는 고유/기본키가 테이블에 있음.





12. VIEW	: 테이블의 일종, 테이블인데 존재하지 않는 가상테이블

(1) 정의 : 실제 테이블을 여러 관점에서 투영한 가상 테이블
(2) 목적

	1) 사용자의 편의
	2) 관리와 보안	: 사용자에게 뷰를 설정하여 보여주고자하는 필드만을 보여주도록 한다.(보안성)


(3) 문법

	CREATE [OR REPLACE] VIEW 뷰이름 [(컬럼명,...)]	*[] 생략이 가능
	AS
	subquery

---------------------------------------------------------------------------------------------------

(4) 실습

	1) 영업부 직원 중 사번, 이름, 급여, 커미션을 view로 작성

	select empno, ename, sal, comm from emp
	where deptno=30;
	//매번 이렇게 작성하는 것은 조금 번거롭다 테이블을 만들도록 한다.

	CREATE VIEW vw_salesman
	AS
	select empno, ename, sal, comm from emp
	where deptno=30;
	// 위처럼 쓰면 끝, 그런데 권한이 불충분하여 생성이 불가능 권한을 주자 관리자에서 grant

	grant create view to scott;
	//권한을 준다. 만들 수 있는. 뷰를. 스캇에게. 그리고 다시 뷰를 생성하면 만들어진다.
	// select tname from tab; 으로 테이블을 조회하면 뷰가 있다. 실제로 존재하진 않지만 존재하는 것처럼 보인다.


	2) vw_salesman에 입사일자를 추가	

	CREATE OR REPLACE VIEW vw_salesman
	AS
	select empno, ename, sal, comm, hiredate from emp
	where deptno=30;

	*note : view는 수정이 안된다. 실제로 존재하는 테이블이 아니므로. 지우고 새로 만들어야한다.
	// OR REPLACE 를 쓰면 추가할 항목이 있으면 재배치하고 없으면 말고


	3) user_constraints, user_objects, user_views

	(user_constraints는 사용자의 제약만을 조회하니 한정적인데 objects는 많은 정보를 확인할 수 있다.)

	desc user_objects	(내가 만든 제약사항도 있고 모든 정보가 있다)

	select object_name, object_id from user_objects;
	//name과 id 를 조회해보자. 그런데 디테일한 정보는 알 수가 없다.
	// view에 대한 상세한 정보를 알고싶다면?

	user_views 를 조회해보자
	
	desc user_views
	
	select view_name, text from user_views;
	//위의 조회를 통해 내가 어떻게 view를 생성했는지 어떤 서브쿼리를 썼는지 보여준다.

	
	4) 뷰를 직접만들어보자.

	Q) 영업부를 제외하고 급여가2000이상인 직원들 중 사번, 이름, 급여, 부서, 부서명, 급여등급을
		조회하는 테이블을 뷰로 작성(vw_2000)

	A)	
		CREATE OR REPLACE VIEW vw_2000
		AS
		select emp.empno, emp.ename, emp.sal, emp.deptno, dept.dname, salgrade.grade 
		from emp inner join dept
		on emp.deptno=dept.deptno
		inner join salgrade
		on sal>=losal and sal<=hisal
		where dname !='SALES' and sal>2000;


-------------------------------------------------------------------------------------------------

(5) 주의할 점

	1) view를 통해 입력되지 않는 컬럼에 대한 설정

	CREATE OR REPLACE VIEW vw_test
	AS
	SELECT ename, deptno, job FROM emp WHERE deptno=30;

	INSERT INTO vw_test VALUES(7777 ,'hong', 30, 'SALESMAN');
	//추가되는 내용은 에러를 발생한다 empno 은 not null 이기 때문에 이런 문제를 어떻게 해결할 것인가?
	//아래와 같이 뷰에 사번을 추가해서 넣어줄 수 있도록 생성한다.


	CREATE OR REPLACE VIEW vw_test
	AS
	SELECT empno, ename, deptno, job FROM emp WHERE deptno=30;


	2) View를 통해 계산된 컬럼이나 파생된 컬럼의 수정

	CREATE OR REPLACE VIEW vw_test
	AS
	SELECT ename, deptno, sal + nvl(comm, 0) as total  FROM emp WHERE deptno=30;

	UPDATE vw_test
	SET total=2000
	WHERE ename='ALLEN';
	
	//위의 업데이트가 가능한가? 불가능해. 가상테이블이라서
	급여는 sal 과 comm으로 가상테이블로 구성되어있다. 2000은 그것을 구분할 수 없다.

	3) view를 통해 여러 테이블을 수정

	CREATE OR REPLACE VIEW vw_test
	AS
	SELECT ename, sal, job, dname, loc 
	FROM emp, dept WHERE emp.deptno=dept.deptno;

	UPDATE vw_test
	SET job='aaa', loc='bbb'
	WHERE ename='SCOTT';

	//이번엔 가상테이블이 아니니까 수정되지 않을까? 안된다. 하나의 트랜젝션으로 묶지 않는 이상.
	insert, update 등 하나는 하나...



	4) 범위를 벗어난 수정

	CREATE OR REPLACE VIEW vw_test
	AS
	SELECT empno, ename, deptno, job, sal
	FROM emp WHERE deptno=30;

	UPDATE vw_test
	SET deptno=20
	WHERE empno=7499;

	//위의 것은 수정이 가능하다. 그런데 뷰에서 수정한다는 것은 위험하다.
	30번 부서에대한 정보를 보는 것인데 뷰에서 부서번호를 바꿀 수 있다니 !
	뷰에서는 이러한 것을 위배로 설정하여 막아야한다. 아래처럼
		
	CREATE OR REPLACE VIEW vw_test
	AS
	SELECT empno, ename, deptno, job, sal
	FROM emp WHERE deptno=30
	WITH CHECK OPTION;

	UPDATE vw_test
	SET deptno=20
	WHERE empno=7499;

	//뷰 테이블을 생성할 때 CHECK OPTION을 설정해주면 제약조건을 걸어주게 된다.



	*note
	//뷰를 지워볼까? drop view vw_test;
	//휴지통을보자 show recyclebin;
	//안에 아무것도 없다. 왜냐면 가상테이블이기 때문에.

	//수정, 삭제 할 필요없도록 read만 하도록 만들어보자.


	CREATE OR REPLACE VIEW vw_test
	AS
	SELECT empno, ename, deptno, job, sal
	FROM emp WHERE deptno=30
	WITH READ ONLY;

	UPDATE vw_test
	SET sal=1700
	WHERE empno=7499;

	//다시 뷰테이블을 작성하고 수정이 가능한 조건 범위 내에서 수정을 실시해보도록 하자.
	//되는가? 되지 않는다. 왜냐면 with read only 제약을 걸었기 때문에.



13. PROCEDURE(Stored Procedure)

(1) 정의 : 자주 사용하는 쿼리문을 미리 컴파일하여 필요할 때 호출
(2) 문법
	CREATE [OR REPLACE] 프로시저명[(파라미터,...)]
	IS
	BEGIN
	END;


(3) PL/SQL에서의 BLOCK
	
	DECLARE
		 -- 선언부

	BEGIN
		-- 실행 및 처리

	EXCEPTION

		-- 예외 처리
	END;

------------------------------------------------------------------------------------------

(4) 실습

	1) 사번이 7788인 사원의 급여를 3500로 수정하는 프로시저를 작성하라.

	select empno, ename, sal from emp where empno=7788;

	UPDATE emp
	SET sal=3500
	WHERE empno=7788;
	//위의 구문대로하면 수정이 되는데 프로시저한다는 것은 위의 구문은 따로 컴파일 해두었다가,
	원할때 호출해서 쓰도록 하는 것을 의미한다. 프로시저로 묶어주자.

	CREATE OR REPLACE PROCEDURE usp_sal
	IS
	BEGIN
		UPDATE emp
		SET sal=3500
		WHERE empno=7788;
	END;
	/

	//확인해보자
	select object_name, object_type From user_objects;

	exec usp_sal;	//호출한다 프로시저를




	2) 좀 더 개선하여 매개변수를 활용

	
	CREATE OR REPLACE PROCEDURE usp_sal(p_empno in number, p_sal in number) //매개변수를 넣어준다.
	IS
	BEGIN
		UPDATE emp
		SET sal = p_sal
		WHERE empno = p_empno;
	END;
	/


	exec usp_sal(7788, 3000);	//매개인자를 넣어서 적용시킨다

	select empno, ename, sal from emp where empno=7788; //바뀐걸 확인한다.

	3) 좀 더 개선하여 메시지를 출력해보자.

		
	CREATE OR REPLACE PROCEDURE usp_sal(p_empno in number, p_sal in number)
	IS
	BEGIN
		UPDATE emp
		SET sal = p_sal
		WHERE empno = p_empno;

		if sql%notfound then
			dbms_output.put_line(to_char(p_empno) || '은(는) 없는 사원번호입니다.');
		else
			dbms_output.put_line(to_char(sql%rowcount) || '명의 자료를 수정하였습니다.');
		end if;
	END;
	/

	//기본 문법의 구성은 다음과 같다. 	-> if ~ then ~ else ~ if
	
	*note

	- sql%notfound 는 하나의 덩어리 변수이다. 
		(sql%은 시스템에서 미리 만들어둔 전역변수(어디서든 사용가능))
		notfound 발견하지 못했나? yes 그렇다 true
	
	- sql%rowcount 	-> 처리된 값을 저장한다. 위의 문장에선 아래와 같이 처리해야할 녀석들
		UPDATE emp
		SET sal = p_sal
		WHERE empno = p_empno;

	
	- dbms_output	-> sqlplus에서만 사용 및 확인가능하다.

	- put_line		-> println 과 비슷한 녀석이다.

	- ||		-> 자바에서 + 와 비슷한 기능으로 연결해주는 역할을 한다.


	//실행해보자
	exec usp_sal(10000, 2000);
	//에러 메시지가 안나오네? 메시지 설정을 해줘야한다
	set serveroutput on	//메시지 설정
	show err			//에러가 발생한다면 어디서 발생하는지 확인할 수 있다.


	4) 특정한 수에 7%의 세금을 계산하여 그 결과를 돌려받을 수 있는 프로시저 작성

	CREATE OR REPLACE PROCEDURE usp_tax(p_num in number, p_result out number)
	IS
	BEGIN
		p_result := p_num * 0.07;
	END;
	/
	
	//리턴을 해주는 방법은 매개변수를 선언해줄 때 in 대신 out 으로 선언해주면 된다.
	//	PL/SQL 에서 대입연산자는 	:=	이다.

	//작성한 내용을 테스트해보는 명령어가 있다.
	//일단 변수를 선언해준다.	var g_result number
	//5000 달러를 입력하고 :g_result를 통해 출력받도록 한다. exec usp_tax(5000, :g_result);
	//print :g_result; 	result 값을 확인해보자.



	(5) 사원 등록 프로시저

	사원 이름, 업무, 직속상사, 급여를 입력받아 등록한다.
	부서번호는 직속상사의 부서번호와 같고,
	커미션은 SALESMAN일 경우 0, 그 외에는 null을 입력하라
	(입사일자는 sysdate)

	CREATE OR REPLACE PROCEDURE usp_register(p_ename in varchar2)
	IS
	BEGIN
		insert into emp(empno, ename, job, mgr, sal, deptno, comm, hiredate)
		values();

	END;
	
	//타입을 지정해줄 때 아래와 같이 지정해줄 수도 있다.

	
	CREATE OR REPLACE PROCEDURE usp_register
		(p_ename in emp.ename%type, p_job in emp.job%type, p_mgr in emp.mgr%type,
		p_sal in emp.sal%type)
	IS
	BEGIN
		insert into emp(empno, ename, job, mgr, sal, deptno, comm, hiredate)
		values(seq_empno.nextVal, p_ename, p_job, p_mgr, p_sal, ?, ?, sysdate);

	END;

	//시퀀스를 만들어주고, 먼저 실행시키자.

	CREATE SEQUENCE seq_empno START WITH 8000;

	// 부서번호와 커미션을 ?, ? 로 처리함 이걸 어떻게할까?
	
	CREATE OR REPLACE PROCEDURE usp_register
		(p_ename in emp.ename%type, p_job in emp.job%type, p_mgr in emp.mgr%type,
		p_sal in emp.sal%type)
	IS
		v_deptno		emp.deptno%type;
		v_comm		emp.comm%type;
	BEGIN
		select deptno into  v_deptno from emp
		where empno=p_mgr;

		IF p_job='SALESMAN' THEN
			v_comm := 0;
		ELSE
			v_comm := null;
		END IF;
	
		insert into emp(empno, ename, job, mgr, sal, deptno, comm, hiredate)
		values(seq_empno.nextVal, p_ename, p_job, p_mgr, p_sal, v_deptno, v_comm, sysdate);

	END;
	
	//위에서 select deptno from emp 로 문장을 작성하면 조회만 가능하지 가져다 쓸 수없다.
	그래서 into를 넣어준다. pl/sql 에서는 반드시. into를 써서 변수에 넣어주고 변수는 ? 자리에 넣어주면된다.
	그리고 선언부인 IS 에 변수를 선언하고 타입도 지정해준다.
	//커미션을 활용하기 위해 IF문을 써주자. insert 에도 담아야하니 이 애도 변수선언해주자 IS에.


	6) 위의 예제를 개선하여 예외처리를 해보자.

	
	CREATE OR REPLACE PROCEDURE usp_register
		(p_ename in emp.ename%type, p_job in emp.job%type, p_mgr in emp.mgr%type,
		p_sal in emp.sal%type)
	IS
		v_deptno		emp.deptno%type;
		v_comm		emp.comm%type;
		v_job_err		EXCEPTION;
	BEGIN
		select deptno into  v_deptno from emp
		where empno=p_mgr;
		
		IF p_job not in('CLERK', 'SALESMAN', 'PRESIDENT', 'MANAGER', 'ANALYST', '') THEN
			raise v_job_err;
		ELSIF p_job='SALESMAN' THEN
			v_comm := 0;
		ELSE
			v_comm := null;
		END IF;
	
		insert into emp(empno, ename, job, mgr, sal, deptno, comm, hiredate)
		values(seq_empno.nextVal, p_ename, p_job, p_mgr, p_sal, v_deptno, v_comm, sysdate);
	EXCEPTION
		WHEN v_job_err THEN
			dbms_output.put_line('업무를 잘못 입력했다.');
		WHEN NO_DATA_FOUND THEN
			dbms_output.put_line('입력한 데이터 없음.');
		WHEN OTHERS THEN
			dbms_output.put_line('기타 에러');
				
	END;

	//예외가 발생하면 다음 문장들을 실행하지 않고 바로 EXCEPTION 으로 넘어간다.
	//예외처리를 할 때는 WHEN을 쓰길 권장한다. IF문을 사용할 수도있는데 코딩이 지저분하다.
	//이도 저도 아닌 조건문일때는 OTHERS를 쓴다.
	//예외처리를 해보자. 위의 문장에 IF문을 하나 더 추가시킬거다.
	//일부러 예외를 발생시키는 것인데 이럴때 쓰는 것이 raise
	//else if 를 작성할 때 elsif 라고 작성한다 오타가 아니다.
	//exception 에서는 v_job_err가 확인되면 아래 문구인 dbms_output.put_line('업무를 잘못 입력했다.');를 출력시키고
	//입력한 데이터가 없다면 no_data_found를 넣어주며, 기타는 others 


	7) 이름을 입력받아 그 직원의 부서명과 급여를 검색하는 프로시저

	CREATE OR REPLACE PROCEDURE usp_search
		(p_ename in emp.ename%type, p_dname out dept.dname%type, p_sal out emp.sal%type)
	IS
		v_deptno		emp.deptno%type;		
	BEGIN
		select sal, deptno
		into p_sal, v_deptno
		from emp
		where ename = p_ename;

		select dname
		into p_dname
		from dept
		where deptno = v_deptno;		
	END;
	/
	

	var g_dname varchar2(14)
	var g_sal number
	exec usp_search('SCOTT', :g_dname, :g_sal);
	print :g_dname;
	print :g_sal;
	print :g_dname :g_sal;

	8) 전화번호를 입력하고 다시 전화번호를 리턴받는 프로시저
	
	1.		

	CREATE OR REPLACE PROCEDURE usp_tel(p_tel in out varchar2)
	IS
	BEGIN
		p_tel := substr(p_tel, 1, 3) || '-' || substr(p_tel, 4);
	END;
	/

	2.
	var g_tel varchar2(20)
	3.
	begin
	:g_tel := 1234567;
	end;
	/
	4.
	exec usp_tel(:g_tel);
	5.
	print :g_tel;

	//1. 입력도 출력도 같이할거니까 매개변수에 in out을 같이 써준다.
	//2. p_tel := substr(p_tel, 1, 3) || '-' || substr(p_tel, 4); 
	//첫번째숫자부터 세번째숫자까지 그리고 대시 이후 마지막숫자까지





14. TRIGGER(=방아쇠, 자바에서의 이벤트이며, 클릭같은 것이 아닌 삽입, 삭제 등의 DML을 의미)

: 마치 프로시저가 자동으로 호출되고 실행까지되는 것과 비슷함

(1) 정의 : 이벤트에 의해 자동으로 호출되어 실행되는 프로시저
(2) 문법

	CREATE [OR REPLACE] TRIGGER 트리거명 {BEFORE|AFTER} 트리거 이벤트 ON 테이블명 [반복문]
	
	BEGIN
	END;


(3) DD : user_triggers
(4) 트리거는 기본적으로 2개의 임시테이블을 가지고 있다.

	NEW(:new), OLD(:old)
	//NEW 또는 :new, OLD 또는 :old

	*note
	그림파일 참조 DB-trigger-new, old, update

--------------------------------------------------------------------------------------------
(5) 실습

	1) emp테이블에서 급여를 수정할 때 현재의 값보다 적게 수정할 수 없고 현재의 값보다
		10%이상 높게 수정할 수 없도록 제한하는 트리거를 작성

	CREATE OR REPLACE TRIGGER tri_emp_update
		BEFORE UPDATE ON emp
		FOR EACH ROW WHEN(NEW.sal<OLD.sal OR NEW.sal>=OLD.sal*1.1)	
		// 반복을 돌겠다 14번 조건절도 올 수 있다 when() 조건이 참이라면 BEGIN 다음 문장을 실행하겠다
	BEGIN
		raise_application_error(-20506, '수정된 값이 잘못되었다.');
	END;

	//업데이트를 할 때 문제의 조건대로 적게수정되면 begin 문장, 10퍼센트 높게수정되면 begin문장을 실행하겠다는 말임
	그것을 반복하겠다는 말.

	//실습해보자.
	

	CREATE OR REPLACE TRIGGER tri_emp_update
		BEFORE UPDATE ON emp
		FOR EACH ROW WHEN(NEW.sal<OLD.sal OR NEW.sal>=OLD.sal*1.1)	
	BEGIN
		raise_application_error(-20506, '수정된 값이 잘못되었다.');
	END;

	//확인
	update emp set sal=1800 where empno=8000;

	//실습후 트리거 삭제
	drop trigger tri_emp_update;



	2) emp테이블을 사용할 수 있는 시간은 월요일부터 금요일까지이며 09시부터 18시까지만
		사용할 수 있도록 하는 트리거를 작성하라.

	
	CREATE OR REPLACE TRIGGER tri_resource
		BEFORE UPDATE OR INSERT OR DELETE ON emp
	BEGIN
		IF to_char(sysdate, 'dy') in ('토', '일', '수') OR to_number(to_char(sysdate, 'HH24'))
		NOT BETWEEN 9 AND 18 THEN
		raise_application_error(-20506, '사용시간이 아닙니다.');
		END IF;
	END;
		
	//IF 조건 THEN 에서 조건은 월~금이 아닌, 09~18이 아닌, 그 외의 요일, 시간대를 적어주면된다.
	//안되는걸 테스트하는 것이므로 수요일을 추가하자.
	//sysdate 'dy' dy는 월, 화, 수, 목, 금, 토, 일 day는 월요일, 화요일, 수요일
	
	//확인해보자
	insert into emp(empno, ename) values(200, '홍길동');



	3) emp테이블에 insert, update, delete 문장이 하루에 몇건이나 발생하는지 조사하려고 한다.
		조사 내용은 emp_audit 라는 테이블에 저장하도록 한다.
		조사 항목은 사용자 이름, 작업구분, 작업시간으로 처리한다.

	CREATE TABLE emp_audit(
		e_id	number(5),
		e_name	varchar2(30),
		e_gubun	varchar2(10),
		e_date	date,
		constraint pi_eid primary key(e_id)
	);

	//1. 테이블을 생성함.

	CREATE OR REPLACE TRIGGER tri_emp_audit
		AFTER UPDATE OR INSERT OR DELETE ON emp
	BEGIN
		IF INSERTING THEN
			insert into emp_audit values(seq_empno.nextval, user, 'inserting', sysdate);
		ELSIF UPDATING THEN
			insert into emp_audit values(seq_empno.nextval, user, 'updating', sysdate);
		ELSIF DELETING THEN
			insert into emp_audit values(seq_empno.nextval, user, 'deleting', sysdate);
		END IF;
	END;

	//2. 트리거 작성

	//3. 삭제해보자 어제 만든 empno 8000
	delete from emp where empno=8000;
	//4. 확인해보자
	select * from emp_audit;
	

	4) 재고 수량 관리 트리거

		- 테이블 설계(입고, 출고, 재고)

			컬럼명		num	name		cnt
			-------------------------------
			key_type		pk	
			sequence	1,1
			null/unique		nn		nn
			datatype		number	varchar2(30)	number



		- 입고 테이블에 데이터를 입력한다.
			자동으로 동시에 재고테이블에 데이터가 입력된다.
			만약 재고 테이블에 이미 동일한 데이터가 있으면
			물건의 갯수만 증가시킨다.

		- 출고 테이블에 데이터를 입력한다.
			자동으로 동시에 재고테이블의 수량이 감소한다.
			만약 재고 테이블의 수량이 출고할 데이터의 수량보다
			적으면 "출고할 수 없습니다." 라는 메시지를 출력하고
			출고테이블에 입력을 중단한다.
			





==============================================================================================
DataBase Modeling

-폭포수 진행방식

1. 의뢰가 들어온다.
2. 요구사항 수집	-> 분석(팀원들에게 알려주기 위한 기본초석)	-> 모델링(기본초석을 그림으로 그린것)

	모델링
	1) 개념적 : 동그라미, 사각형, 삼각형 등을 활용한 모델링
	2) 논리적 : mySQL을 쓸지, oracle을 쓸지 아직 결정하지 않은 단계의 설계
	3) 물리적 : 어떤 database program을 쓸지 결정하는 설계 단계

	*note : 위의 세 단계는 사실 한꺼번에 한다. 개념적 단계는 거의 무시한다.

3. 구현 : 일단 DB부터 준비한다.
	
	3-1. 디버깅(테스트)

4. 납품
5. 유지보수


*Agile 방식 (단기간 프로젝트에 맞춘 설계방식)
요구사항수집하고 분석하자마자 바로 모델링 코딩하는 방식.


================================================================================

정규화
------

제 1 정규화	: 속성은 오직 하나의 원자값을 취해야 한다.
제 2 정규화
제 3 정규화
	일반
	강한
제 4 정규화
제 5 정규화
...


http://www.dbguide.net/event/dbmodel_2009/data/erwin.zip


프로젝트

산출물
---------
1. 발표ppt
	- 조원소개
	- 역할분담
	...

2. ERD

	- 개념적 모델링
	- 논리적 (물리적)모델링

3. UML

	- Class Diagram
	- Sequence Diagram

4. 소스

	- Java, sql 파일

5. 프로시저 설계도


6. 테이블 상세 스키마


노하우

*누구의 입장에서 만들어지는지를 보자. (클라이언트)
예제에서보면 쇼핑몰 입장에서 만드는 것임.

식별관계 : 부모 테이블의 기본키가 자식테이블의 기본키로 전이되는 관계.(보통 식별관계는 1:1관계를 의미한다.)

비식별관계 : 부모테이블의 기본키가 자식테이블의 일반컬럼으로전이되는 관계(1:다 관계)


다대다 관계선 우클릭 create association entity 다음다음해주면 1 대 다로 구현해준다.



============================================================================================

UML

============================================================================================
아마테라스 준비(자바에 플러그인 형태로해서 사용할 수 있다)
다운받은 아마테라스의 압축을 해제하면, jar 파일 3개가 나온다. 그것을 이클립스 plugin 안에 붙여넣기한다.


*note

git 이라는 프로그램은 내 컴퓨터에서만 저장이되며 공동으로 쓰기 위해서는 서버관리가 필요하다.
서버 관리를 구축하려면 네트워크관리도 해야하고 불편하다 그래서 나온게 github 이라는 사이트 !
github을 쓰기위해서는 git을 먼저 알고 github을 아는게 순서이기는하다. github은 외국사이트
우리나라에서는 jandi가 있다. 모바일, pc 둘다 지원한다.




==========================================================================================

Semi Project

==========================================================================================

시연 : 6월말 예정

주제 선정 : 어떤 롤 모델로 할 것인지 사이트같은 것 제출할 것.
		강사님과 팀 미팅할 것임. 2주간 코딩과 디버깅작업함 그전까지는 디자인이 끝나야함


1. 주제선정
2. 요구사항 분석서
	
	1) 고객 요구사항
	2) 개념적 ERD

3. 벤치 마킹 사이트 소개
	- 어디 사이트를 롤 모델로 삼았는가(홈)

4. 스토리 보드
	- 디자인  ppt (어떻게 프로그램이 실행될 것인지)

5. 프로젝트 개요서 작성

	1) 프로젝트명
	2) 참여인력
	3) 추진목표
	4) 추진전략
	5) 추진일정 : 프로젝트 추진일정 (네이버검색)

6. 팀명


============================================================================================

응용프로그램 VS 웹프로그램


응용프로그램 : 한대의 컴퓨터에서 돌아가는프로그램
웹프로그램 : 서버를 바탕으로 수십 수백 수천대의 컴퓨터에서 돌아갈 수있다.

웹프로그램 : 

클라이언트


-------------------------------------------------------------------------------------

HTML(Hyper Text Markup Language)

<>데이터<> : 이렇게 생긴언어가 마크업 랭귀지 (데이터를 양쪽으로 애워싸서 마크하는 것처럼보임)

<> : 시작태그 <>: 끝태그 이 꺽쇠들을  Element(요소) 라고한다.

HTML 은 1버전부터 4버전까지 나왔다. 그리고 4버전까지가 마지막버전이라고 발표했었다.
그러나 CrossBrowsing 즉, 모든 브라우져에 HTML4가 호환되지 않아서 이 발표를깨고
xhtml이 출시했다. 
게다가 어도비 플래시에서 라이센스를 요구하자, HTML은 이에 대응하여 HTML5 버전을 출시했다.


첫번째 설명
이클립스내에 작성했으며, 실습은 노트패드에서 진행, 그림파일 참고할 것.


-------------------------------------------------------------------------------------

JSP(Java Server Page)

*note 
인터넷 초창기 보급시절 환경

	- 게시판은 사용자와 운영자와의 소통의 장소

	- CGI(Common Gateway Interface)
		: C, Perl, C++ 과 같은 언어
		: Servlet 이 등장했다. 하지만 너무 어려움, 방안으로 다소 쉬운 JSP가 등장했다.

	- JSP
		: JSP를 배우기에 앞서 Servlet을 배울 것이다.



--------------------------------------------------------------------------------------
Web Program
--------------------------------------------------------------------------------------
1. 두가지 코드 방식으로 작성
	(1) Server Side : Java
	(2) Client Side : JavaScript, Html
	
2. 준비사항
	(1) 웹 서버 프로그램 : 아파치 톰캣 9버전(7버전선호)
		인터넷페이지창에 localhost:8080 입력하면 톰캣화면 나옴 그럼 문제없음.
		
		프로그램 소개
			- IIS (무료로 사용할 수 있으며 마이크로소프트에서 제공하고 윈도우에서 제공된다. 종합서버)
			- Apache
			- Tomcat
			
			- 유료 : Regin , Websphere(무겁고 비싸다 IBM제품), WebLogic, Jeus(우리나라 프로그램), JBoss, ...
			- ...
			
	(2) 웹 프로젝트
			프로젝트 폴더
				WEB-INF
					classes
					lib
					web.xml


3. 서블릿(Servlet)

	: 애플릿처럼 응용프로그램을 작게 만든것처럼 생각하면 된다.
	: 즉, 서버에서 실행되는 프로그램의 규모를 조금 더 작게 만들었다.('=. 자바프로그램을 서버에서만 실행할 수 있도록 한다)

	(1) 특징
		1) 자바로 만든 프로그램
		2) 서버에서만 실행
		3) 클라이언트와 소통 가능
		4) 별도의 라이브러리 필요(servlet-api.jar)
		5) 반드시 이것을 상속받아야 서블릿이라고 할 수 있다. HttpServlet 상속


	(2) 서블릿을 구성하는 3대 클래스
		1) HttpServlet
			javax.servlet.GenericServlet
				Interface Servlet
					destory()
					init(ServletConfig config) : 서블릿 시작(단 한번만 실행)
					service(ServletRequest req, ServletResponse res) : 사용자가 호출하면 호출하는대로 서비스가 호출된다.


==================================================================================================

* HTTPServlet 관련된 내용 :  web.xml

==================================================================================================

<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee
                      http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
  version="4.0"
  metadata-complete="true">

  <display-name>Welcome to Tomcat</display-name>
  <description>
     Welcome to Tomcat
  </description>
  
  <!-- 
  톰캣에 의해 인스턴스가 생성되기 위한 역할
  1. life라는 참조변수이름 작성
  2. (패키지명 기재)myservlet.LifeCycleServlet 클래스명 작성
  -->
	<servlet>
		<servlet-name>life</servlet-name>	
		<servlet-class>myservlet.LifeCycleServlet</servlet-class>
	</servlet>
  
  <!-- 클라이언트가 현재 실행중인 서블릿에 어떻게 접속하게 할 것인가에 대해 작성 -->
	<servlet-mapping>
		<servlet-name>life</servlet-name>
		<url-pattern>/life</url-pattern>
	</servlet-mapping>
	  <!-- http://localhost:8080/webapp2/life -->
</web-app>

==================================================================================================
==================================================================================================



			

		2) HttpServletRequest
		3) HttpServletResponse




		Class HttpServlet	protected void	doGet(HttpServletRequest req, HttpServletResponse resp)
				protected void	doPost(HttpServletRequest req, HttpServletResponse resp)


		Interface ServletRequestString	getParameter(String name)
						String[]	getParameterValues(String name)

	(3) 요청(Request) 방법
		1) GET
			- 하이퍼링크 전송방식, URL전송방식
			- 전송방법이 다양하다.
			- 소량의 데이터만 전송이 가능하다. 
			(많은 양의 데이터를 보내면 누락된다. 
			바디가 아니라 헤더에 담아 보내기 때문에 적은 양만 보낼 수 있다.
			헤더로 보내면 보내기가 쉽고 편하다.)
			- 전송되는 데이터가 노출되기 쉽다. (중요한 내용이면 GET방식으로 보내지 말것)
			- 기본 전송 방식
			- 주로 데이터 조회 목적으로 사용된다.

		2) POST
			- 폼 전송 방식
			- 전송 방법은 단 한가지만 존재한다.
			- 대량의 데이터를 전송할 수 있다.(바디에 담아서 보내기 때문에)
			- 전송되는 데이터가 노출되지 않는다.
			- 데이터 변경의 목적을 갖는다.

	(4) 데이터를 전달 받는 방법(HttpServletRequest)
		1) getParameter()
		2) getParameterValues()	: 배열의 갯수를 가져온다
		3) getParameterNames()	: 값의 주소, 이름을 가져온다. (값을 가리키는 변수명을 가져온다)
		4) getParameterMap()


	(5) 헤더 정보 알아오기

	(6) 웹 프로그래밍에서 중요한 기술 2가지
		1) 페이지 이동 기술
			- HTML
				<a> : anchor 태그, 페이지 이동이 메인 기술
				<meta> : '몇 초후에 이동한다' 라고 했던 태그
			
			- Javascript
				location
				history

			- Java(나중에 정리한다 jsp의 actiontag 참고)

		2) Data Persistance (데이터 지속)
			1) Cookie		: 클라이언트에 정보 보관
						- 텍스트로만 저장 가능
						- 하나의 서버당 저장할 수 있는 쿠키는 4kb
						- 만료기간 
						------------------
						쿠키 : 만료기간이 정해져 있는 쿠키를 그냥 쿠키라고 한다.
						메모리 쿠키 : 만료기간이 정해져 있지 않는 쿠키를 메모리 쿠키라고 함.
						

			2) Session	: 서버에 정보 보관(서버 메모리 부담이 크다 1명이면 1개 100명이면 100개)
						HttpSession
							long	getCreationTime() : 사용자가 접속하면 시간이 생성되는데 이를 가져옴.
							String	getId : 이렇게 만들어진 세션의 아이디를 알아온다.
							long	getLastAccessedTime() : 마지막 접속시간을 알아온다. 
											그래서 계정을 정리할 수 있거나 접속을 끊게한다. 
											(초단위로 보여준다 new Date( ) 로 포장하면 날짜로 출력해준다.)
							int	getMaxInactiveInterval() : 얼마동안 작업을 하지 않았는지 알려준다.
							void	invalidate() : 세션을 강제로 삭제한다.
							boolean	isNew() : 처음 접속했는지 아닌지 알려준다.
							void	setMaxInactiveInterval(int interval) : 세션 만료시간을 지정할 수 있다.
							void	setAttribute(String name, Object value) : 세션의 값을 지정할 때
								get				: 세션의 값을 가져올때
								remove				: 세션의 값을 지울때

			*note Data Persistance가 Cookie 와 Session 을 갖는 이유
			
				- http는 비연결지향성 
				: 연결을 하지 않는 것이 아니라, 지속적으로 연결을 하지 않는다.
				웹은 동시접속을 원칙으로 하기 때문에 지속적으로 연결하면 접속인원에 한계를 가지기 때문이다.

				- 클라이언트와 서버
				: 클라이언트가 서버에 요청을하면 연결이 된다. 
					ex) www.naver.com 을 입력하면 네이버에 접속이 되며, 네이버에서 응답을 한 순간 이미 나와 네이버의 접속은 끊어진 것이다.
					즉, 요청과 응답이라는 하나의 사이클이 이뤄지면 접속이 끊어진다는 것을 의미한다.
					이 하나의 사이클(요청과 응답)을 round trip 이라고 한다.
					서버는 클라이언트에 대한 기억을 가지지 않는다. 요청과 응답의 사이클을 가지면 모든 기억을 삭제한다.
					그런데 회원이라는 것을 어떻게 알고 서비스를 지원하는가? 쿠키와 세션으로 가능하도록 했다. 웹 자체로는 불가하기 때문이다.



				- Cookie 라는 기술은...
	
					사용자가 요청하면 사용자에게 응답은 하면서 사용자의 하드디스크에 임시적으로 저장하는 방식이며,
					이 방식을 바탕으로 사용자의 대한 정보를 기억하는 것을 쿠키라고 한다.

				- Session 이라는 기술은

					쿠키와 다르게 서버에서 사용자의 정보를 보관하는 방식을 의미한다.
					쿠키는 사용자 하드에, 세션은 서버에 정보를 저장한다.




======================================================

jar cvf ../web3.war *	압축하기 - > 톰캣 webapps 안에 넣어주기

======================================================



======================================================

이클립스에서 다이나믹 프로젝트를 만들때 이름쓰고 next - next - 이제는 xml로 안쓰고 class 를 쓰는데 지금은 xml 만들어서 쓰자

======================================================


======================================================

서버를 켜고, localhost:8080 가서 example 보면 socket에서 echo는 서버가 살았나 죽었나 살펴볼 수 있다.

======================================================



4. JSP(Java Server Page)

기존에는 html 과 서블릿을 따로 만들어서 관리했다. JSP는 이 두가지를 통합해 한페이지 안에서 구현할 수 있도록 했다.

(1) 클라이언트 코드와 서버코드를 한 페이지 안에서 작성 가능
	html을 포괄적으로 사용하고 그 안에 java 코드를 넣는 방식

	- HTML 안에 java 코드를 포함시키는 방법
	- 저장방식 : 확장자를 .jsp 로 한다.


(2) 구성요소
	1) Template Data(정적 데이터) : HTML, XML, ...
	2) Elements(동적 데이터) : Java
		- ScriptElement : HTML 안에 자바코드를 포함시키기 위한 도구이다.
			<%! ... %> : 선언부 Declaration
			<% ... %>  : 처리부 scriptlet
			<%= ... %>: 출력부 Expression

		- Directive : 지시를 내리기 위한 도구이다.
			<%@ page %>
			<%@ include %>
			<%@ taglib %>
		

		- Implicit Object

			request		: HttpServletRequest(서블릿을 활용해서 request를 만들었으니 도큐먼트 참고해서 할 것)
						request는 입력의 기능으로 사용된다.(서버기준으로 보기때문에)					
			response		: HttpServletResponse
			out		: javax.servlet.jsp.JspWriter
			----------- 입출력 관련 객체(3) (out 빈도수 낮아 학습제외)




			page
			config
			----------- 서블릿 관련 객체(2) (빈도수가 낮아 학습제외)

		

			(request)		: request는 입력의 기능을 수행하면서 동시에 컨텍스트의 기능을 수행한다.
					: a 와 b 페이지 사이의 응답과 요청사이에서만 사용이 가능한 범위를 가진다.
					지역변수 개념

			session		: 전역변수개념
			application	: 전역변수개념
			pageContext	: javax.servlet.jsp.PageContext (전형적인 지역변수개념이다. 
									다른페이지에서는 출력이 안된다.
									그런데 페이지컨텍스트는 활용도가 높다.
									req, sess, appli 에 모두 접근할 수 있다.)


					*컨텍스트 객체들이 공통으로 가지는 메소드들*

					setAttribute("변수명", 값)
					getAtrribute("변수명")
					removeAttribute("변수명")

			------------ 컨텍스트(=메모리장소) 관련 객체(3)


			exception
			------------ 예외 관련 객체(1) (빈도수가 낮아 학습제외)
		

		- ActionTag	: 정적(Tag)인 데이터인 HTML을 동적(Action)인 방식으로 사용할 수 있도록 하는 것.
				우리가 배운 jsp 코딩방식의 문제(jsp 내에 html 내에 java코드)
				1. 협업이 불가능, html(디자인)이 먼저 나와야 코딩을 할 수 있다.
				2. 디자이너와 개발자간의 갈등

					대안 :	1. 자바코드를 별도의 클래스로 분류
						2. 자바코드를 따로 불러 쓸 수 있도록 ActionTag 방식 구현
						3. HTML과의 조화를 위해 Tag로 구현함
						4. 결과적으로 jsp 내에서 자바코드를 쓰지말자. (자바클래스에서만 작성하자)
						5. 이때 jsp를 보여주는 프레젠테이션 로직, 
						자바는 실제 기능을 담당하는 비지니스 로직이라 한다.

				1) <jsp:include />	(jsp-include 그림파일, ActiontagApp 프로젝트의 exam1,2 참고)
					- 페이지 이동(복귀)
					- request 객체(지역변수)
					- 파라미터 전달 가능(exam3,4)


				2) <jsp:forward />
					- 페이지 이동(페이지에서 다른 페이지로의 전형적인 이동을 의미)
					- 흐름을 제어

				
	
					- 사용자 정의 ActionTag
						: JSTL (다른 개발자들이 따로 만들어 놓은 actiontag 라이브러리)

		- EL



(3) 유효성 검사
	1) 클라이언트측 검사
	2) 서버측 검사


(4) ActionTag
		- HTML
			<a> : anchor 태그, 페이지 이동이 메인 기술
			<meta> : '몇 초후에 이동한다' 라고 했던 태그
			<form action=" "><input type="submit" /></form>
				
		- Javascript
			location
			history

		- Java
			<jsp:include />
			<jsp:forward />
			response.sendRedirect()
			<%@ page errorPage%>


		위의 8가지 기술에 대해서 2가지로 분류해보자.
			- 클라이언트측 이동기술
				<a>
				<meta>
				location
				history
				response.sendRedirect()

			- 서버측 이동기술
				<jsp:forward />
				<jsp:include />
				<%@ page errorPage%>

(5) Java Bean

	1) 특징
		- java로 만든 클래스(프로그램)
		- 서버에서 실행
		- jsp 와 소통한다. (서블릿과 비교해보길.. 서블릿은 사용자(클라이언트)와 소통한다.)

	2) Bean Tag(아래의 방식을 추구해야한다  '<% %>' 이 코드를 충분히 줄일만큼)

		*note : bean 클래스를 만들때는 반드시 패키지를 만들어야한다.

		<jsp:useBean />
			- Bean의 인스턴스 생성을 해주는 액션태그
			- 이미 인스턴스가 생성되어 있을 경우, 참조 역할로 사용가능

		<jsp:getProperty />
			- getter 메소드를 호출할 때 사용
			- 화면에 출력하는 기능을 가진다.

		<jsp:setProperty />
			- setter 메소드를 호출할 때 사용




	3) Java Bean 규칙
		- 반드시 패키지 작성해야한다.
		- 반드시 public으로 지정해야한다.
		- 프로퍼티 규약
			getter 메서드
				반드시 get(소문자)으로 시작
				get 다음에 시작되는 첫번째 문자는 대문자로 작성한다.
				반드시 return type이 존재해야한다(void는 불가하다)
				반드시 매개변수가 없어야한다. (값을 꺼내오기 위함이기 때문에)
				
				*getter 메서드는 get으로 시작하는 메서드만 불러오는 것이 아니라 
					is로 시작하는 메서드도 불러올 수 있다.

			setter 메서드
				반드시 set(소문자)으로 시작
				set 다음에 시작되는 첫번째 문자는 대문자로 작성한다.
				반드시 return type이 void 이여야 한다.
				반드시 매개변수가 있어야 한다. (매개변수가 필요없다해도 만들어야한다)


	4) Bean의 사용범위
		- page
		- request
		- session
		- application
		
	5) Bean의 종류(프로퍼티 = 메서드)
		- 참/거짓 프로퍼티
			public boolean isValid(){
				...
				return [true or false];
			}

		- 인덱스 프로퍼티
			리턴 타입이 배열인 메서드를 인덱스 프로퍼티라 한다.
			그런데 ActionTag 는 배열을 처리할 수 없다. get property는 값을 하나만 리턴할 수 있다.
			즉, 인덱스 프로퍼티는 자바코드를 사용해야한다는 것을 의미한다.

---------------------------------------------------------------------------------------------------------

공지
참고해보세요~
부비스트랩 (트위터, 반응형웹개발 등에 도움되는 자료)

---------------------------------------------------------------------------------------------------------
(6) DB연동
	*v1의 코드는 좋지 않은 코드, 아래의 항목에 모두 포함된다.
	
	- 중복된 코드(사용자가 바뀌거나, DB프로그램이 바뀌면 페이지를 다 바꿔야한다)
	- 직접적인 연결시도(직접 연결하고 직접 연결을 해제하면 DB에 과부하가 걸린다)
	- DB에 동시 접속 제한

	1) DBCP(DataBase Connection Pool) : 위의 항목을 해결하기 위함
	
		- 중복된 코드
		- 직접적인 연결시도
		- DB에 동시 접속 제한

	2) 사용 방법

		- 직접 작성
		- 외부 라이브러리(아파치의 DBCP, C3P0, ...)
		- WAS에서 제공



		*note

		JNDI(Java Naming and Directory Interface)는 
		디렉터리 서비스에서 제공하는 데이터 및 객체를 발견(discover)하고 
		참고(lookup)하기 위한 자바 API다.


	3) Bean으로 구현(최대한 분리시키는 작업)

		* server.xml 에서 편의를 위해서 글로밍에다가 작성했다. 그런데 이를 또 설정하기 위해 web.xml을 건드렸다.
		편의를 보장받고자.이를 해결해보자.
		일단 context.xml 을 건드린다. 맨 아래 적당한 위치에 web.xml의 resource 코드를 붙여넣기한다.
		그럼이제 web.xml을 건드리지 않아도 된다.


(7) UI 프레임워크


*** 부트 스트랩

	1) 버전
		- 1.x : PC환경을 지원하기 위함
		- 2.x : PC환경을 주로하며 모바일도 지원
		- 3.x : 모바일환경 우선, PC환경도 겸용

	2) 레이아웃

		- 2단, 3단 레이아웃 구성
		- 고정크기, 가변크기
		- 반응형 디자인(Responsive Design)




(8) 게시판

(9) 파일 업로드

(10) MVC(Model View Controller) - 모든 프로젝트는 MVC 방식으로 진행되어야한다.

	: 요청은 컨트롤러에게 처리는 모델이 출력은 뷰가하는 역할분담 방식
	: *모든 요청은 컨트롤러에 모아놓고 한다.
	: 사용자가 요청하면 컨트롤러가 받는다. 컨트롤러는 요청을 받아 모델에게 일처리를 넘겨준다.
		모델은 일처리를 하고 컨트롤러에 보고한다. 컨트롤러는 보고받은 내용을 뷰에게 넘겨준다.
		뷰는 잘 보여지도록 처리하여 사용자에게 넘겨준다.


	: 컨트롤러는 servlet, 모델은 bean, 뷰는 jsp 

	개발하는 방식

	1) Model 1 Architecture : 소규모, 프로토타입의 프로젝트는 모델1 방식을 추천한다. (기존의 방식 jsp에서 모든 처리 및 bean을 활용한 방식)
	2) Model 2 Architecture : 대규모 방식에는 모델2를 추천한다. (역할분담 방식)



(11) EL(Expression Language) : 출력을 담당하는 언어

	http://blog.naver.com/vanillasea81/220399862362(참고사이트)
	*EL은 반드시 변수가 get 과 set 메소드를 사용하여 선언되어있어야 사용할 수 있다.

	예제공부 : ElApp

	1) 출력기능(지금까지 배운 출력기능 정리)
		- <%= ... %> 	: expression(출력부)
		- out.println()	: 되도록이면 쓰지말라고 권장한다. (자바코드를 써야하는데 디자인이 다깨진다.)
		- <jsp:getProperty ... />	: 액션태그의 getProperty (제약이 심하다. 값을 하나만 받을 수 있다. 객체는 받을 수 없다)

		위의 세 가지는 모두 단점이 있다. 
		이것들을 커버하고 간편하게 쓸 수 있도록 한 것이 EL이다.
		EL을 알게되면 위의 출력기능들은 사용하지 않아도 된다.


	2) EL의 문법 : 아래의 문법 하나가 전부. ${식}
		

	3) ${식}

		- ${attribute명} 또는 ${xxxScope.attribute명} (xxx에는 pageContext, request, session, application 이 들어갈 수 있다.)
			:attribute 란 setAttribute, getAttribute, removeAttribute 메서드를 통해 저장되고 관리되는 데이터를 일컫는다.

		- ${bean명} 또는 ${map명}
		- ${EL 내장객체}
		- ${객체.프로퍼티} 또는 ${객체["프로퍼티"]}


	4) 내장 객체

		-pageScope
		-requestScope
		-sessionScope
		- applicationScope
		

		- param
		- paramValues
		

		- header
		- headerValues
		

		- cookie
		

		- initParam 


		- pageContext	: 위의 객체들은 저장된 값을 출력하는 기능만 있는데, pageContext는 고유의 기능을 모두 가지고 있다.


	5) 사용자 정의 함수

		우리가 ActionTag를 쓰는 목적이 무엇인가? 
		: 페이지에서 자바코드를 안쓰려고, 태그로만 이루어져있도록 하려고.
		: 하지만 jsp에서의 표준코드는 몇개 없기 때문에 자바코드를 안쓰기에는 너무 부족하다.
		: 이에 대한 대안책으로 '사용자 정의 Tag' 가 있다.

		참고 사이트
		http://blog.naver.com/tyboss/70032746060
		http://blog.naver.com/judge41/140105495861 

		TLD 파일을 만들기 위해서 xml로 만든다.



		<?xml version="1.0" encoding="UTF-8"?>
		<taglib version="2.0">
		<tlib-version>1.0</tlib-version>
		<short-name>test1</short-name>
		<uri>test1</uri>
		<function>
			<name></name>		->별명
			<function-class>myservlet.ElTestServlet</function-class>		-> 담겨있는 클래스
			<function-signature>String printMessage()</function-signature>		-> 실제 메서드 명
		</function>
		</taglib>


		==========================================================
		
		따로 메서드를 지정하지 않고 java에서 제공하는 메서드를 사용할 때의 방법	
			


		<?xml version="1.0" encoding="UTF-8"?>
		<taglib version="2.0">
		<tlib-version>1.0</tlib-version>
		<short-name>test2</short-name>
		<uri>test2</uri>
		<function>
			<name>root</name>
			<function-class>java.lang.Math</function-class>
			<function-signature>doublesqrt(double)</function-signature>
		</function>
		</taglib>


(12) JSTL(JSP Standard Tag Library)
	1) 라이브러리 준비
		- taglibs-standard-impl-1.2.5.jar, taglibs-standard-spec-1.2.5.jar
		- jstl.jar, standard.jar(위의 jar와 같다)
		- javax.servlet.,jsp.jstl-api-1.2.1.jar

		- 또는 톰캣에서 제공해주고 있다.
		교육장의 폴더위치는 F:\apache-tomcat-7.0.69\webapps\examples\WEB-INF\lib

		- lib 에 붙여넣기

	2) 역할 및 특징
		- EL이나 표준액션태그로 처리하기 힘든 부분 담당
		- 연산, 조건, 반복처리
		- 개발자가 따로 구현 가능
	
	3) 구성요소

		항목
		- Core
			1. 일반 프로그래밍에서 제공하는 것과 유사한 변수 선언, 실행 흐름의 제어 기능을 제공
			
			2. 페이지 이동 기술을 제공(redirect, import, url)
				JSTL 은 이미 클래스와 TLD 가 연결되어있으므로 JSP의 이동기술이 추가로 필요한 것이다.
				uri : http://java.sun.com/jsp/jstl/core

		- Formatting(형식을 지정할 때 사용된다)

			숫자, 날짜, 시간을 포매팅하는 기능과 국제화, 다국어 기능을 제공한다.
			uri : http://java.sun.com/jsp/jstl/fmt
	
		- Database
			DB의 데이터를 수정, 삭제, 입력, 조회하는 기능을 제공	
			uri : http://java.sun.com/jsp/jstl/sql

		- Xml
			XML 문서를 처리할 때 필요한 기능을 제공
			uri : http://java.sun.com/jsp/jstl/xml			


		- Function	
			문자열을 처리하는 함수를 제공
			uri : http://java.sun.com/jsp/jstl/functions






*.XML(Extensible Markup Language 특징)

1. 메타언어 : 언어를 만드는 언어(메타언어 -> 자바, C#, C++, C -> APP
	
	GML -> SGML -> XML

2. 데이터를 위한 언어

3. DB의 역할

4. 데이터의 표준화

	이기종 시스템간의 정보 교환, 웹서비스, 유비쿼터스 기타 등등


문법)
XML, DTD(.dtd), XML 스키마(.xsd), XSL

	- DTD 와 XML스키마는 XML을 만드는 설계도
	- DTD 는 간단하지만 설계가 단순하며 세밀한 설계가 어렵다.
	- 스키마는 다루기에 복잡하고 다양하지만 세밀하고 확장성이 좋다.
		디자인이 예쁘지 않아 이를 보완하기 위해 나온 것이 XSL이다.

1. XML문서 종류

	1) well-formed xml document(잘 짜여진 문서): XML 문법에 맞게 잘 만들어진 문서
	2) valid document(유효한 문서) : DTD, XML와 같은 설계도에 맞게 잘 만들어진 문서

2. XML문서의 구조
	반드시 갖추고 있어야하는 갯수
	Prolog - 1개
	Element - 1개
	Misc	0개 이상

3. ELEMENT
(1) 작성 문법

	1) 모든 XML문서는 반드시 단 하나의 루트 엘리먼트를 갖는다.
	2) 루트엘리먼트는 여러개의 자식 엘리먼트를 가질 수 있고 또 그 자식도자신의 자식을 가질 수 있다.

(2) 종류

	1) 내용을 가지는 엘리먼트
	2) 내용이 없는 엘리먼트

(3) 작성 규칙

	1) 시작태그와 끝태그는 반드시 짝을 이루어야 한다.
	2) "<"는 값으로 사용불가. ">"는 사용할 수 있으나 가급적 사용금지
	3) "<"와 ">" 다음에 공백문자가 올 수 없으며 반드시 시작태그명과 이름이 같아야 한다.

(4) 엘리먼트의 내용
	1) 문자 데이터
	2) 자식 엘리먼트
	3) 엔티티 또는 문자 참조
	4) CDATA section
	5) 프로세싱 지시자
	6) 주석
	7) 공백 문자열

(5) DTD
	1) 종류
		- 내부 DTD
		- 외부 DTD

	2) 구성요소
		- 엘리먼트 선언
		- 속성(Attribute) 선언
		- Entity 선언
		- Notation 선언
		- 프로세싱 지시자
		- 파라미터 엔티티 참조
		- 주석
		- 공백
		- conditional section


	3) 문서 유형 선언
		<!DOCTYPE 루트엘리먼트명 SYSTEM 또는 PUBLIC "식별자">	
			: SYSTEM 은 비공개용이며 PUBLIC은 공개용

		- DOCTYPE은 반드시 대문자
		- SYSTEM은 특정 단체나 업체내부에서 사용되는 경우
		- PUBLIC은 공개
		- 식별자는 다운로드 받을 수 있는 경로
		- PUBLIC 일 경우의 추가된 식별자

	+-//DTD를 개발 및 유지보수 업체명 // DTD명 및 버전번호 // 사용된 언어
			: 바로 위의 내용은 식별자(PUBLIC)일 경우 추가되는 내용이다.


	4) ELEMENT 선언
		
		- <!ELEMENT 엘리먼트명 컨텐트 유형>
		- 컨텐트 유형
			#PCDATA : 내용으로 문자데이터만 갖는 엘리먼트
		
			자식엘리먼트
					, : 작성순서

					| : 선택

					? : 생략하거나 한번만 작성

					+ : 한번 이상

					* : 생략하거나 여러번 작성

					기호없음 : 단 한번만 작성

			EMPTY
			MIXED	: 문자 데이터 또는 자식엘리먼트를 혼합형태로 가진다.

			ANY

	

	5) ATTRIBUTE 선언

		- <!attlist 엘리먼트명 속성명 속성유형 디폴트선언>
		- 속성 유형
			CDATA : 문자 데이터
			ENUMERATION : dtd에 나열된값 중 하나가 와야 함
			ID : 유일한 값ㅇ르 지정
			IDREF / IDREFS : ID 값을 참조
			NMTOKEN/NMTOKENS : 이름 작성 규칙을 준수하는 데이터만 사용
			NOTATION : dtd에 명시적으로 선언된 notation만 사용 가능
			ENTITY : dtd에 명시적으로 선언된 entity만 사용 가능



(6) 네임 스페이스
CML
---------------
	<?xml version="1.0>
	<정보>
		<고유번호>111111-1111111</고유번호>
		<이름>홍길동</이름>
		...
	</정보>

PML
---------------
	<?xml version="1.0">
	<정보>
		<고유번호>LC100</고유번호>
		<이름>캠코더</이름>
		...
	</정보>
OML
---------------
	<?xml version="1.0">
	<주문정보 xmlns:고객="http://www.abc.com/2015/Custom"
		xmlns:제품="http://www.abc.com/2015/Product"
		xmlns="http://www.abc.com/2015/Order">	
	
	(xmlns에는 절대로 중복되지 않을 도메인을 써주면 된다.)

		<주문번호>1</주문번호>
		<주문수량>10</주문수량>
		<결제>
			<방법>현금</방법>
			<금액>1000000</금액>
		</결제>

		<! --CML의 내용-->
		<고객:고유번호>111111-1111111</고객:고유번호>
		<고객:이름>홍길동</고객:이름>

		<! --PML 내용-->
		<제품:고유번호>LC100</제품:고유번호>
		<제품:이름>캠코더</제품:이름>		
		...
	</주문정보>


(7) Java 연동

	1) DOM
		: 전체 데이터를 올려두기 때문에 구조파악이 쉽다.
		: 전체 데이터를 올려두기 때문에 처리속도 및 접근이 용이하다.
		: DomAPI를 활용할 수 있어 좋다. 트리구조로 접근이 용이.
		
		- 1. xml에 있는 데이터를 메모리에 전부 옮겨 놓는다.
		- 2. xml에서 불러온 데이터를 전부 트리구조로 재구성한다.

	2) SAX

		: 메모리에 대한 부담이 없다.
		: 필요할 때마다 데이터를 계속해서 불러들여야하기 때문에 성능저하가 우려된다.

		- 1. xml의 일부 데이터(필요한데이터)를 메모리에 올려둔다.


--------------------------------------------------------------------------------------------------------
#2016.05.30
*** AJAX(Asynchronous Javascript And XML)
	:AJAX는 새로운 기술이라기보다 사용자의 편의성을 보장하는 기술 집약체이다.
	:Asynchronous - 비동기화 기술
	:Javascript - 클라이언트에서 javascript를 이용하여 서버에게 요청(**AJAX를 잘하기 위해선 자바스크립트 기술이 필수)
	:And XML 
	
	참고사이트 : https://developer.mozilla.org/ko/docs/AJAX/Getting_Started
	
	
1. Asynchronous - 비동기
	: 우린 그동안 클라이언트와 서버와의 관계에서 동기식으로 처리하고 있었다.(요청을 주고 받고)
	ex)동기식 기술
	
		폼방식
		<form action=" ... ">
			submit
		</form>
		하나의 요청을 하고 하나의 응답을 받아 또 다른 요청을 할 수있는 방식
	
		하이퍼링크 방식
		<a href=" ... ">
		
		스크립트방식
		<script>
			document.form.submit();
		</script>
	
	하지만 AJAX에서는 비동기란 기술을 사용한다. 
	비동기란 한번에 하나의 요청을 보내는 것이 아니고, 계속해서 요청을 보낼 수 있는 방식이다.
	요청을 보내고 응답이 오지 않았음에도 또 다른 요청을 보낼 수 있다. 
	서버에서는 조금 불편하더라도 사용자 입장에선 편의성을 보장받을 수 있다.

2. **Javascript - 요청하는 방식
	: 동기식에서는 사용자의 의지로 요청했다. (버튼식, 링크식 등등)
	하지만 AJAX에서는 사용자의 의지와 상관없이 자동적으로 서버에게 요청하는 기능을 수행한다.
	ex)
	만일 클라이언트에서 서버에게 100번의 요청을 해야한다면 기존 방식이라면 사용자가 100번의 버튼을 눌러야했을 것이지만
	AJAX에서는 자동적으로 100번의 요청을 수행한다. 반면 서버에 렉이 발생하는 문제점이 있을 수 있다.

3. XML - javascript에서 요청한 내용에 대해서 데이터를 보내는데, 디자인화 하지 않고 데이터만 보내는 방식(xml로)
	: 클라이언트에서 디자인 작업이 수행되어야한다. 전형적인 클라이언트 기술이며 서버코드는 거의 사용되지 않는다.
	서버에서는 데이터만을 전송하며, 데이터는 xml형식으로 처리된다. 
	디자인화되어 보내않으므로 클라이언트에서 파싱하여 디자인과 모든 처리를 해야한다.
	따라서 전형적인 클라이언트 기술이라하며 html, css, javascript의 세가지 기술의 조화가 잘 이루어져야한다.

4. XMLHttpRequest 객체의 추가 등장 : 어느 웹프로그램에서는 실행되고 안되고의 문제점을 해결하기 위한 표준화 객체
	: 개발자들의 저마다 다른 방식을 통합하여 모두 사용할 수 있도록 한 객체가
	
	ex) 
	Google Map : 지도상에서 보고 있던 지역에서 다른 지역을 보기 위해 드레그하면 깜빡거렸는데 
					Google map은 자연스럽게 움직였다. 이때 적용된 기술이 AJAX이다.
	
	Naver 검색 자동 제시어 : a만 입력해도 검색 자동 제시어가 나타난다. AJAX 기술이다.

=======================
실습을 통해 더 배워보기
basic01.html - basic01.html 파일 및 basic01.jsp 파일 참고
=======================

====================================================================================================
XML -> Json
XML에서 태그의 사용이 많아짐에 따라 파일의 크기가 커졌다. 그래서 이를 보완한 것이 Json이다.
====================================================================================================
5. JSON(Javascript Object Notation)

(1) 서로 다른 프로그래밍 언어간에 데이터를 교환하기 위한 표기법
(2) 읽고 쓰기 쉬운 표기법(XML보다 쉽다)
(3) 문법
	1) map형식
		중괄호로 묶고 그 안에 이름과 값을 한쌍으로 표기한다.
		ex) {이름:값, 이름:값, 이름:값, ...}
	2) array형식
		대괄호로 묶고 그 안에 값을 표기한다.
		ex) [값, 값, 값, ...]


		
---------------------------------------------------------------------------------------------------------		
---------------------------------------------------------------------------------------------------------


	jQuery : 기본알맹이는 js


---------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------
1. 참고 사이트
	http://www.jquery.com/
	http://www.jqueryui.com/
	http://www.w3schools.com/ - learnJquery
	
2. 특징
(1) 가볍고, 빠르며, 간결한 오픈소스 자바스크립트 라이브러리
	
	라이브러리 종류
	Prototype, Dojo, mootools, yui, *node.js, ...

(2) 막강한 CSS 셀렉터
	
	CSS 셀렉터란?
	div a {디자인...}
		: div공백이면 a라는 자식에 {} 디자인을 적용하겠다.

(3) 크로스 브라우저 지원

	여러 브라우저에서 구동이 될 수 있도록 호환성을 지니도록 한다.(단, 100%는 아님)
	
	과거방식
	익스플로러6면 ... 문장을 실행하라.
	if(익스플로러6){
		...
	}
	
(4) Ajax 지원


(5) 풍부한 플러그인 지원

(6) 메서드 체인 지원
	
그 외 여러가지...

3. 문법
(1) 형식
	jQuery(); : jquery의 시작형태. 이 문법형태가 길다면, $(); 이렇게 작성도 가능하다.
	
	$();
(2) 라이브러리 사용법
	1) 다운로드하여 직접 연결하는 방식
	2) CDN : 네트워크를 연결하여 라이브러리를 연결하는 방식(최근 이 방식을 많이 채택함)
				https://code.jquery.com
				https://code.jquery.com/jquery-2.2.4.js 		


(3) jQuery Selector
	1) HTML DOM을 마음대로 traverse(탐색) 가능
	2) CSS Selector를 사용하여 원하는 객체 탐색

	ex)CSS Selector 활용 예시
		div p{color:red}	: div의 자식 중 모든 p에 대해서 {} 디자인을 적용하겠다.
		#loginID{...}		: ID가 login 인 속성에 대해서 {} 디자인
		.Colums{...}		: class가 Colums인 것에 대해 {} 디자인
		*{...}
	
		위의 CSS를 동일하게 jQuery에서 사용가능
			$("div p")
			$("#loginID")
			$(".Colums")
			$("*")
			
		추가적으로 CSS에는 없는 다양한 기능을 jQuery에서 보완했다.
			$("div > p") : div 의 직속자식들인 p 에게 적용
			

		-----------------------------------------
		jQuery의 css 기호를 정리해보자.
		
		*					모든 요소와 일치하는 것을 선택
		E1					E1인 모든 요소와 일치하는 것을 선택
		E1.class			클래스 속성에 접근할 수 있다.
		E1#id				
		E1 E2				E1 안에 있는 E2라는 자식들을 모두 선택하겠다.
		E1 > E2				E1 요소의 바로 아래 자식인 E2요소와 일치하는 모든 것을 선택
		E1 + E2				E1 요소의 바로 다음에 나오는 형제 요소 E2와 일치하는 첫번째 요소를 선택
		E1 ~ E2				E1 요소의 다음에 나오는 모든 형제 E2와 일치하는 모든 것을 선택
		E1[attr]			attr 속성을 갖는 E1요소와 일치하는 것을 선택
		E1[attr=val]		attr 속성의 값이 val을 갖는 E1요소와 일치하는 것을 선택
		E1[attr^=val]		attr 속성의 값이 val로 시작하는 E1요소와 일치하는 것을 선택
		E1[attr$=val]		attr 속성의 값이 val로 끝나는 E1요소와 일치하는 것을 선택
		E1[attr*=val]		attr 속성의 값이 val을 포함하는 E1요소와 일치하는 것을 선택

(4) jQuery Selector : Filter
	*필터는 무조건 앞에 콜론(:)이 들어간다.

	1) 기본 필터
		:first			- 선택된 객체들 중 첫번째 요소와 일치하는 것을 선택
		:last		 	- 선택된 객체들 중 마지막 요소와 일치하는 것을 선택
		:not(selector)	- 괄호에 주어진 selector와 일치되는 모든 요소를 제외하고 선택
		:even			- 짝수 요소들과 일치하는 것을 선택(*주의 : 0부터 시작)
		:odd			- 홀수 요소들과 일치하는 것을 선택
		:eq(index)		- 인덱스에 해당하는 단일 요소와 일치하는 것을 선택
		:gt(index)		- 주어진 인덱스보다 높은 인덱스를 갖는 모든 요소와 일치하는 것을 선택
		:lt(index)		- 주어진 인덱스보다 낮은 인덱스를 갖는 모든 요소와 일치하는 것을 선택
		:header			- 모든 헤더요소(h태그)와 일치하는 것을 선택
		:animated		- 현재 애니메이션이 동작중인 모든 요소와 일치하는 것을 선택
		
	2) 컨텐트 필터
		:contains(text)	- 지정한 텍스트를 포함하는 요소들과 일치
		:empty			- 자식을 가지지 않는 모든 요소와 일치, 더불어 내부 텍스트를 가지지 않는 요소들도 이에 해당
		:has(selector)	- 지정된 selector에 해당하는 요소를 갖는 모든 요소들과 일치
		:parent			- 부모인 모든 요소들과 일치 자식요소를 갖는 요소뿐만 아니라 텍스트를 갖는 요소들도 이에 해당
		
		
	3) 자식 필터
		:nth-child(index|even|odd)	- 자식 중 index로 지정된 위치의 요소들과 일치되거나 even, odd에 해당하는 자식들과  일치한다.
										단, 여기서의 index는 1부터 시작한다.
										
		:first-child				- 첫번째 자식인 모든 요소와 일치
		:last-child					- 마지막 자식인 모든 요소와 일치
		:only-child					- 자신이 부모 요소의 유일한 자식인 모든 요소와 일치				
										
	4) 폼 필터
		
		:input
		:text
		:password
		:radio
		:checkbox
		:submit
		:image
		:reset
		:button
		:file
		:hidden
		-------
		:enable
		:disable
		:checked
		:selected

(5) Manipulation Method(조작해주는 메서드)
	1) 내용 변경 메서드
		html()
		html(val)
		text()
		text(val)
		
	2) 추가 관련 메서드(요소 내부에 추가하는 경우)
		append(content)
			$("셀렉터").append(...) : 셀렉터를 선택하고 append 내의 내용을 추가하겠다.
		appendTo(selector)
			$(...).appendTo("셀렉터") : 앞에 있는 내용을 뒤에 추가하겠다.
		prepend(content)
		prependTo(selector)
		
	3) 추가 관련 메서드(요소 외부에 추가하는 경우)
		after(content)
		insertAfter(selector)
		before(content)
		insertBefore(selector)
		
	4) 삭제 메서드
		empty()		- 모든 일치된 요소들의 자식 노드를 제거
		remove()	- 모든 일치된 요소들을 제거(자기자신)
		
	5) 복사 메서드
		clone()			- 일치된 요소를 복사하고, 그를 선택
		clone(boolean)	- 이벤트 처리기를 포함하여 복사하고, 그를 선택

(6) Traversing Method(탐색 관련 메서드)
	1) eq(index)
	2) filter(expr)
	3) filter(function)
	4) is(expr)
	5) map(callback)
	6) not(expr)
	------------------------------
	eq
	ex)필터에서의 eq와 동일하다.
	필터 - $("div:eq(1)").addClass("blue")
	탐색 - $("div").eq(1).addClass("blue")
	
	차이점
	end() 사용
	
	$("div:odd").eq(0).css("background", "orange);
	$("div:odd").eq(1).css("background", "blue);
	$("div:odd").eq(2).css("background", "red);

	중복코드를 줄이기
	$("div:odd")
		.eq(0).css("background", "orange")
		.end()
		.eq(1).css("background", "blue")
		.end()
		.eq(2).css("background", "red");
	----------------------------------------------
	odd
	ex)필터에서의 odd와 동일
	
	필터 - $("div:odd")
	탐색 - $("div").filter(":odd")

	차이점
	end()사용
	
	$("div").filter(":odd").end()
	------------------------------------------------
	$("div").filter(":odd")
			(=)
	$("div").not(":even")
	------------------------------------------------
	var $var1 = $(".test").eq(5)
	
	if($var.is("div")){		//is : 같으냐...?
		//처리
	}

	var $var2 = $("div").eq(5)
	$var2.is(".orange, .blue, .lightblue")	//하나라도 같으면 true
	----------------------------------------------------------
	var arr = 	$("div").map(	//중간에 다리를 놔주는 map
					function(){
						return $(this).next().text().toUpperCase();
					}
				);
	----------------------------------------------------------
	7)	find(expr)
	8)	add(expr)
	9)	next(expr)
	10)	nexAll(expr)
	11) parent(expr)
	12) parents(expr)
	13) prev(expr)
	14) prevAll(expr)
	15) siblings(expr)	: 형제들
	----------------------------------------------------------
	find
	ex)
	$("div:odd").filter("p")	
	//셀렉터 내에서 필터한다.근데 말이 안된다. 이미 찾아놓은게 div인데 거기서 p태그를 찾겠다? 결과는 당연히 없다.
	
	$("div:odd").find("p")
	//find는 div를 찾아서 그 자식 중에 p태그가 있는지 찾는다.
	
	
	----------------------------------------------------------
	add
	ex)
	$("div").add("p")
	//이렇게 추가한다는 것은 div와 p태그는 동급으로 되는 것이다. 즉 찾을 때 $("div p")로 찾으면 안되고
	//$("div, p") 방식으로 찾아야한다.
	
	Q1) 어디에 색이 적용될까? A) 둘다 적용된다. div에 p태그를 동급으로 추가하는거고 거기에 색을 입히는 거니까
	$("div").add("p").css("background", "yellow");
	
	Q2) 적용 모습은 어떤가? A) div는 보더와 컬러를 모두 적용받고 p태그는 컬러만 적용받는다.
	$("div")
		.css("border", "1x solid red")
		.add("p")
		.css("background", "yellow")
	
	----------------------------------------------------------
	
(7) CSS관련 메서드

	1) css(name)
	2) css(name, value)
	3) css(properties)	
		: 디자인을 여러개 묶어서 해줄 수 있다. properties는 반드시 json 형식으로 해줘야한다.
		: {키:값, 키:값, ..}
	4) addClass(class)
	5) hasClass(class)
	6) removeClass(class)
	7) toggleClass(class)
	
(8) Attribute 관련 메서드
	
	1) attr(name)
	2) attr(name, value)
	3) attr(properties)
	4) attr(name, fn)
	5) removeAttr(name)
	
	
(9)	이벤트 관련 메서드
	1) bind(type, data, fn)
	2) unbind(type, fn)
	3) one(type, data, fn)
	4) trigger(event, data)
	--------------------------------------
	ex)
	click 은 정식적인 방식은 아니다.
	$("mybtn").click( function(){//처리} );
	
	정식적인 방식은 bind를 사용해야한다. 
	$("mybtn").bind("click"); //() 내에 어떤  type인지
	
	$("mybtn").bind("click", {data}, function(){//처리}); //function에 전달할 data가 있다면 작성 없다면 바로 fn 작성
	
	$("mybtn").bind("click", {name:"홍길동", age:"20"}, function(e){
		alert(e.data.name
	}); //data 가 있다면 json형식으로 작성하고 function에 매개변수를 넣어 데이터를 저장할 수 있도록해서 불러다 사용할 수 있다.



#6.23 Spring Frame Work(Day01 - GIT)
--------------------------------
GIT
--------------------------------
기술면접에서 용어를 묻기도 하니 잘 알아둘 것.

*. SCM(Software Configuration Management) : 형상 관리
	SW개발 및 유지보수 과정에서 발생하는 소스코드, 문서, 인터페이스 등 각종 결과물에 대해 형상을 만들고, 
	이들 형상에 대한 변경을 체계적으로 관리, 제어하기 위한 활동
		-프로젝트를 진행하면서 생성하는 소스코드를 CVS나 SVN(SubVersioN), 또는 GIT와 같은 버전관리 시스템을 이용하는 것.
		(최근에 이용흐름이 SVN보다 GIT를 많이 사용한다.)
		
*.공식사이트(GIT) : https://git-scm.com/
	
	git의 서버로 활용할 수 있는 사이트들
		github, bitbucket, gitlab, yobi, ...
	
	GIT-Book(PDF)
	
		1.버전관리방식(저장방식)
		: 로컬 -> 중앙(SVN) -> 분산(GIT) ~ p.26
		
			1-1. 세 가지 상태 p.30	~
			:working directory 에서 작업한 내용을 git directory(DB)에 저장해야하는데 중간에 거치는 과정(Staging Area)이 있다.
			반드시 Stage Area에 들어가야 DB에 저장할 수 있다. commit을 누르면 DB에 저장된다.
			
			1-2. Git 설치 p.31~
		
	
*. GIT 사용방법
	1) 콘솔
	2) GUI
	
*. 형상관리를 위해서 알아둬야하는 용어 몇 가지(trunk, tag, branch)
	Spring-branch.png 파일 참고
	
---------
GIT 실습
---------
	1. 사용자 정보 p.35~
	
		실습을 하기에 앞서 가장 먼저 해야할 것, 아무폴더에서 우클릭 bash 아래 명령어 실행, 사용자 이름, 이메일바꿔서.
			$ git config --global user.name "John Doe"
			$ git config --global user.email johndoe@example.com
	
			global은 나만 사용할 때.

	2. Git 저장소 만들기 p.39~
		저장소는 내 ?퓨터에서 하는 방식과 서버를 이용하는 방식이 있다.
		일단 내 컴퓨터를 저장소로 사용하는 방식에 대해 배워보자.
			
			준비물
			f:\GitWorkspace\TestProject1
			Test1.java, web.xml 생성(txt에서 확장자만 변경함)
			
			1. Local에 저장하는 방식
		
				1. TestProject1 폴더의 우클릭 - bash 명령창 열고 $ git init 명령어 입력하면 DB생성된다.
				
				2. 명령창에 git status(상태) 입력 - untracked files 라면 관리할 수 없는 상태임을 나타냄
					(untracked files: "git add <file>..." add를 사용하면 관리할 수 있는 상태로 만들어준다.)
					
						git add Test1.java
						git add web.xml
					
					위의 두 명령어를 입력하여 stage에 올리도록한다.
					
					git status 를 한번 더 입력하면 commit 할 수 있다는 메시지를 확인할 수 있다.
					(stage에 올려져있다는 것을 의미)
					
					$ git rm --cached web.xml 명령어를 입력하면 unstage 된다.
					다시 web.xml을 스테이지에 올려주고 커밋한다.
	
					$ git commit
					그럼 커밋한 파일의 정보를 입력하는 메모장 형태가 실행된다.
					
					i를 누르면 insert(타이핑)할 수 있는 모드로 변경되고 입력 후에 esc하고,
					콜론 : 으로 명령어를 입력할 수 있도록해서 wq 를 입력하면 저장된다.
					
					$ git commit -m "주석 : 남길 메시지 작성하는 공간" 으로 따로 메모장을 실행하지 않고 메모를 저장할 수 있다.
		
				3. 커밋된 파일을 수정하는 방법 p.41 ~
				: 커밋된 파일을 수정하게 되면 stage 단계에서 내려와 modified 상태가 된다. 그리고 다시 stage 에 올려야한다.
	
					Test1.java 를 수정하고 bash 명령창으로 가서 status를 확인하면 (red)modified 상태로 확인된다.
					이대로 commit 하면 commit 이 complete 되지 않는다. add를 사용하여 stage로 올려야한다. 
					
					$ git add Test1.java 입력
					(green)modified : Test1.java 확인
					$ git commit -m "Test1.java를 수정함" 으로 커밋한다.
					
					$ git log 입력 : 현재까지의 작업내용이 나온다.
					
					
	
	

		서버에 저장하도록 해보자.
		
			준비물
			- Githup에 가입하기.
			- 기존에 저장했던 폴더는 지우자.

			1. githup 서버주소로 프로젝트 생성하기
				
				$ git clone 서버주소
				-> 이후에 stage에 담고 서버에 올리는 작업까지해주면 된다.
				
			2. 어느 서버에 저장되어있는지 알기
				
				$ git remote
				-> origin 이라고나오는데 이것은 변수, 별명이라고 생각하면 된다.
				
				$ git remote -v
				-> 서버 주소나 올리고 받고에 대한 정보를 더 자세히 알 수 있음.
				
				$ git push origin master
				-> 저장되어있는 origin(변수)에 master(trunk)를 보내겠다.(올리겠다)
				-> 아이디/비밀번호를 확인하게된다.


			3. 프로젝트 관리
			
				만일 githup 내, 또는 외부에서 githup 계정에 파일을 올리게 되면,
				업로딩된 파일을 먼저 다운받아야 새로운 파일을 push할 수 있다.
				
				받는 방법에는 fetch 와 pull 이 있으며 fetch는 단순히 파일을 다운, pull은 소스까지받아서 병합하는 작업을 한다.
				
				$ git pull origin(서버의 별명) master(자신의 컴퓨터)
				-> 만일, none-fast-forward가 출력되면 로컬의 소스내용이 server 소스보다 오래된 것이므로 다운받아 commit 하기를 의미함.


		브랜치(branch)
			제 3장 p.77~
			Head는 현재 커밋된 기본정보를 가르킨다.
			-> 첫번째 커밋, 두번째 커밋, 세번째 커밋이 있다면 세번째 커밋을 헤드는 가리키게 되고 
			그 헤드가 가리키는 것은 마스터이다. 그리고 커밋을 해야 헤드라는 것이 생긴다.
			
			index라고하면 stage와 같은 의미라고 생각하면 된다.

			브랜치만들기
			
				- 브랜치를 만들면 커밋을 가리키고 있던 마스터 외에 추가되는 가지가 생긴다. 이때 헤드는 마스터만을 가리킨다.
				- 헤드가 브랜치를 가리키게 하고 싶으면 checkout을 통해서 바꿀 수 있다.
				- 교재의 내용대로 3개의 파일을 커밋해보겠다.
				- $git log --oneline --decorate 을 입력하면 현재 헤드가 어디를 가리키고 있는지 알 수 있다.
				- $git branch mem_reg
					-> mem_reg 라는 이름의 branch를 만들었다. 하지만 아직까지 현재의 브랜치는 마스터이다.
					
				- 이때 네번째의 파일을 추가하고 커밋하고 스테이터스를 확인해도 master로 브랜치가 되어있다.
				- 하지만 $git checkout mem_reg 로 브랜치를 변경하면 a4의 파일은 확인이 안된다.
					-> master는 원본파일을 보관하고 있고, branch 로 변경된 mem_reg는 a4를 추가하기 전인 a3까지만 보관을 하고 있다.
					-> 즉, master로 브랜치가 되어있을 때, a1~a3를 만들고 커밋하다가, mem_reg라는 브랜치를 만들었다.
					그런 후, 아직 브랜치변경이 안된 브랜치가 현재 마스터인 상태에서 a4를 만들었는데, 브랜치를 변경하고 난 뒤에보니
					mem_reg에는 a4가 없다. 
			
				p. ~81까지 브랜치 숙지하기
				
					브랜치 병합하기
					
					$ git diff master mem_reg
					-> 비교하는 기능
					
					$ git merge mem_reg
					-> 병합되면서 master에 병합된 파일이 들어간다.
					
			이클립스로 활용하기.(스프링에 최적화된 이클립스는 STS)
			www.spring.io
			프로젝트 우클릭 - Team - ShareProject
			다른 기능들은 이클립스 내에서 쉽게 이해할 수 있다.
			
#6.27 Spring Frame Work(Day03 - TDD)
--------------------------------
TDD
--------------------------------

TDD(Test Driven Development)란 무엇인가?
: 테스트 위주로 개발하는 방식

1. 왜 써야하는가?
: 고전(폭포수 방식)적인 개발 방식에서 나타날 수 있는 문제?
	1) 특정 모듈 개발기간이 길어질수록 개발자의 목표의식이 흐려진다.
	2) 작업분량이 늘어날수록 확인이 어려워진다.
	3) 개발자의 집중력이 필요하다.
	4) 논리적인 오류를 찾기가 힘들다.
	5) 코드의 사용법과 변경이력을 개발자의 기억력에 의존하게 되는 경우가 많다.
	6) 코드 수정시에 기존 코드의 정상 동작에 대한 보장이 어렵다.
	...

2. TDD를 한마디로 표현하자면, "Test the program before you write it."

	------------------
	예제실습(TddTest1)
	------------------
			
- 자바 프로젝트를 생성하고 테스트를 미리 만들어보자.
- 스펙을 주석으로 만들어준다.
( method 이름은 sum , 인자는 int a, int b로 구성, 조건(condition), 예 ) 
- calculator 를 주제로 선정해서해본다.




- false 가 반복해서 나오고 마지막에 true가 나오는데, false를 true로 바꾸는 것이 테스트의 목적이다.

3. TDD의 가장 분명한 목표(Goal) : Clean code that works. - 동작이 원활하게 되고 코드는 깔끔하게.

TDD의 테스트는 개발자와 사용자의 테스트 중 개발자 테스트(단위 테스트 : 메서드)에 속한다.
(*단위 테스트는 기능을 잘게 쪼갤 수 있는 만큼 쪼갠 메서드를 의미한다.)

4. TDD테스트 진행 방식
(1) 질문 : 테스트 코드를 먼저 작성하라.(이 기능이 올바르게 수행하는가? 기획한대로 동작하는가? 답은 false)
(2) 응답 : 질문에 대한 답인 false를 true로 변경하는 작업 즉, 코드작성
(3) 정제 : 변수명 등 코드를 깔끔하고 가독성을 높여 작성
(4) 반복 : 위의 과정을 반복



5. Bank1 프로젝트 생성(은행업무 프로그램 실습)

프로젝트 시작전에 Todo List 만들기(코딩에 자신없다면 반드시 리스트를 만들라)
==========================================
***Todo List***(전제조건: 테스트메서드는 독립적)
클래스명 : Account
기능은 세가지
- 잔고 조회
10000원으로 계좌 생성
잔고조회 결과 일치
- 입금
10000원으로 계좌 생성
1000원 입금
잔고 11000원 확인
- 출금
10000원으로 계좌 생성
1000원 출금
잔고 9000원 확인
비고 : 금액은 원 단위로(예 : 천원=1000)
==========================================
1) 첫번째 질문 : 계좌 생성 테스트(인스턴스 생성은 했는가? = Account 클래스는 제대로 만들어졌는가?)
- 메서드를 만들어서 테스트하라.
- 실패 확인

2) 첫번째 응답 : 계좌 생성 테스트를 통과하는 코드 작성
3) 첫번째 정제 : 코드를 깔끔하게 하라. 어떻게?
- 소스의 가독성이 적절한가?
- 중복된 코드는 없는가?
- 이름이 잘못 부여된 메서드나 변수명은 없는가?
- 구조의 개선이 필요한 부분은 없는가?
...
----------------------------------------------------------------------------------------------------------------
1) 두번째 질문 : 잔고 조회가 잘 되는지?(코드가 없는데 당연히 잘 안된다.)
2) 두번째 응답 : 잔고 조회 구현(잔고조회 통과하는 코드 작성)
3) 두번째 정제
- business code에서 변수명 수정
- Test code에서 assertEquals() 사용

----------------------------------------------------------------------------------------------------------------
1) 세번째 질문 : 입금/출금
2) 세번째 응답 : 
3) 세번째 정제

6. TDD의 장점
(1) 개발의 방향을 잃지 않게 유지해준다.
(2) 품질 높은 소프트웨어 모듈 보유
(3) 자동화된 단위 테스트 케이스를 갖게 된다.
(4) 사용설명서 & 의사소통의 수단
(5) 설계 개선
(6) 보다 자주 성공한다.

7. JUnit(위의 테스트를 좀 더 손쉽게 하도록 도와주는 툴)
(1) 공식사이트 : www.junit.org
(2) 단위 테스트 프레임워크 중 하나(라이브러리랑 헷갈리지 말고 구분하자)
- 라이브러리는 프로그램 내에 종속되어 하나의 부분으로 기능
- 프레임워크는 독립적으로 실행되어 도움을 주는 것
(3) 문자 혹은 GUI 기반으로 실행됨
(4) xUnit 이라 불리는 스타일을 따른다.
(5) 결과는 성공(녹색), 실패(붉은색) 중 하나로 표시
(6) JUnit3, JUnit4

*Tip 메서드를 생성할 때 Test Ctrl + Spacebar tap tap

(7) 대표 메서드

assertEquals(예상값, 실제값)
assertEquals("설명", 예상값, 실제값)
assertXXX()

AccountTest.java 의 fail이 들어간 가정문을 줄일 수 있다.(fail의 기능도 포함한다)


(두번째, 세번째 질문 JUnit 대표메서드)


(JUnit의 대표메서드 assertEquals를 활용한 예)

(정제를 도와주는 이클립스 단축키)

ctrl + 1 활용		
			

(8) 구성요소

	1) Assertion
	2) Test Fixture : 일관성있게 반복적으로 수행할 수 있게 도와주는 실행환경
	3) Test Runner: 테스트를 실행시켜주는 것

8. JUnit3
:두 개의 규칙과 4개의 구성요소로 이루어짐

(1) 규칙
1) 반드시 TestCase를 상속받는다.
2) 테스트 메서드의 이름은 반드시 소문자 test로 시작

(2) 구성요소
1) Test Fixture Method 
-setUp(), tearDown() : 테스트 메서드가 실행될 때마다
 자동적으로 두 메서드(setUp, tearDown)는 실행된다.
			
2) Assertion
- assertEquals([message], 예상값, 실제값) 
*대괄호의 메시지는 생략가능

assertEquals([message], 예상값, 실제값, 오차값)
: 예상값과 실제값이 실수(double)일 경우, 오차값을 넣을 수 있다.

- assertTrue([message], 예상값)/assertFalse(...)    : 예상값이 참/거짓이어야 성공

- assertNull([message], 예상값)/assertNotNull(...) : 널이어야/널이아니어야 성공

- assertSame([message], 예상값, 실제값)/assertNotSame(...)
(equals는 값을 비교 == 는 객체(주소)를 비교)

- fail([message]) : 주로 try/catch 대신에 사용, 작업 책갈피로 사용

3) Test Runner
junit.swingui.TestRunner.run(테스트클래스.class)
junit.textui.TestRunner.run(테스트클래스.class)
junit.awtui.TestRunner.run(테스트클래스.class)

4) Test Suite : 여러개 클래스를 연속적으로 사용하고자할 때


(TestCase를 쉽게 자동적으로 만들어주기 위한 과정 : project 가 아닌 package 주의)

(JUnit4)

9. JUnit4
(1) Annotation 지원
(2) Annotation의 지원으로 test라는 글자로 method 이름을 시작해야 한다는 제약해소
ex)테스트 메서드에 @test 지정
(3) 좀 더 유연한 Fixture 제공
@Before, @After, @BeforeClass, @AfterClass

------------------------------------------------------------------------------------------
실습 예제 : 서버 접속 - 로그인 - 로그인 확인 메시지 서버 전송 - 서버 메시지 회신
------------------------------------------------------------------------------------------

(4) 예외 테스트
@Test(expected = 예외처리클래스.class) *NumberFormatException.class

(5) 테스트 시간 제한
@Test(timeout=1000) : 밀리세컨드로 1000 = 1초

(6) 테스트 무시
@Ignore @Test

(7) 배열 지원
@assertArrayEquals()

10. TDD의 한계

(1) 동시성 문제
(2) 접근 제한자
(3) GUI
(4) 의존성 모듈 테스트
(5) TDD에 대한 인식

11. Mock 객체


(암호화 복호화를 위한 MD5)

참고
MemberTest.java
UserRegister.java
Cipher.java
MD5Cipher.java

http://www.miraclesalad.com/webtools/md5.php
(암호화 복호화 참고 사이트)


==================================================
apache Maven : 프로젝트의 관리를 손쉽게 할 수 있는 툴
==================================================
과거에 Ant를 사용하다가 Maven으로 추세가 옮겨갔음. 현재 Gradle이 그 뒤를 쫓고있음
- Ant
- Gradle

1. 목표 및 특징
(1) 빌드절차를 간소화 : 통합된 빌드 시스템을 제공
(2) Quality Project Information 제공
: 개발에 있어서 Best Practice를 위한 지침 제공

(3) 프로젝트 관리도구
(4) 모듈간의 의존성을 관리하는 매커니즘을 제공
(5) 소스코드의 디렉토리 구조를 표준화 시켜준다.
...




2. 개념
(1) Project Object Model(POM) : 현재 프로젝트의 관한 정보를 저장하는 모델
- Maven은 XML에 Project에 대한 정보를 기술
- pom.xml

(2) Dependency Management Model
- 모듈간의 참조를 위한 dependency를 관리하는 방법이 표준화 되어있다.
- pom.xml에 의존하는 모듈만 기술하면 된다.

(3) Build Lifecycle & Phase
		phase
		(phase는 라이프사이클을 가지고있다. 중간에 test를 실행하면 아래의 validate부터 쭉 실행된다는 것을 의미한다.)
		*복합적으로 실행가능(활용)
			ex) mvn clean package(=초기화를 먼저하고 패키징하겠다.)
		--------------------
		validate
		initialize
		generate-sources
		...
		compile				: 자바파일을 컴파일하는 기능
		process-classes
		...
		test-compile
		test				: 자바파일을 테스트하는 기능
		package				: 패키징하여 jar파일로 생성
		...
		verify
		install				: 프로젝트를 local repository로 저장
		deploy				: 로컬에 있는 파일을 원격서버에 저장하는 기능(배포하는 기능)
		clean				: 테스트한 내용을 초기화하는 기능
		

3. Maven의 Repository
(1) Local Repository : .m2 (.git 과 비슷한 개념이다.)
(2) Remote Repository

4. Maven의 Plugin
: 핵심 코어를 제외한 모든 것은 플러그인으로 기능을 확장한다.
필요할 경우 Remote Repository에서 다운로드하여 사용한다.

- 기본 플러그인 :  https://maven.apache.org/plugins/index.html

모든 플러그인은 Goal의 집합이다.
#mvn javadoc:jar

*javadoc 은 도큐먼트처럼 저장하겠다는 것을 의미

/**
/*
자바소스
*/

위 처럼 사용하면 도큐먼트처럼 저장된다.
			
5.  Maven의 Archetype
	(1) 프로젝트의 기본 구조 제공
		: 프로젝트마다 서로 다른 디렉토리 구조를 통일
		
	(2) 프로젝트의 템플릿을 통해 프로젝트의 구조를 자동으로 생성
	(3) 기본 type
		maven-archetype-archetype
		maven-archetype-j2ee-simple
		maven-archetype-mojo
		maven-archetype-portlet
		maven-archetype-quickstart
		maven-archetype-site
		maven-archetype-site-simple
		maven-archetype-webapp
		...
		
6. 프로젝트 구조
	Project Root
		src
			main
				java
				resources
				filters
				assembly
				config
				webapp
			test
				javaresources
				filters
			site
			
------------------------------------------------------------------------------------
====================================================================================
Spring		
스프링 API 북마크 : http://docs.spring.io/spring/docs/current/javadoc-api/
필요한 lib는 메이븐을 이용해서 다운받을 것이다.
	
====================================================================================			
1. http://spring.io
2. Spring Framework
	
	라이브러리와 프레임워크는 다르다.
	둘다 jar로 되어있지만 라이브러리는 필요에 의한 수동적, 프레임워크는 능동적이다.
	
	스프링 프레임워크는 다방면에서 사용된다.
			
3. 전자정부 프레임워크(스프링이 각광받게 된 이유)			
4. EJB => Spring(EJB가 무엇인지 정도는 알고있자)
5. 정의: 엔터프라이즈 어플리케이션에서 필요로 하는 기능을 제공하는 프레임워크
			코드를 구성하는 틀이며 틀을 가져다가 사용하는 것. 쉽지 않다. 사용법을 익히는데 오래걸림
6. 특징
	(1) J2EE가 제공하는 다수의 기능을 제공
	(2) 경량 프레임워크
	(3) DI패턴을 지원
	(4) AOP패턴을 지원
	(5) POJO(Plain Old Java Object)를 지원
	(6) Transaction처리를 위한 일관성있는 방법을 제공(DB의 All or Nothing)
	(7) 영속성(Data Persistence)과 관련된 다양한 API제공
	...		
			
7. 대표적인 패턴
	
	(1) DI패턴
	(2) AOP패턴
	(3) MVC패턴

--------------------------------------------------------------------------------------------------------------

** 객체 지향 설계 원칙(SOLID)
1. SRP
2. OCP
3. LSP
4. ISP
5. DIP

--------------------------------------------------------------------------------------------------------------		
8. DI(Dependency Injection)패턴
	Dependency : 객체와 객체 간에 연결되어있는 결합성
	ex) A클래스와 B클래스가 있을 때, A클래스가 실행되기 위해서 B가 필요할 때 A는 new B()로 인스턴스를 선언한다.
		이때 이를 A가 가지는 B의 의존성이라고 한다. 이때, B가 어떤 변화를 가지게 되면, A 역시 변화를 가져야하며
		A가 가지는 다른 클래스들도 모두 변화과정을 가져야한다. 이러한 단점을 약화시키기 위해 의존성을 줄일 필요가 있다.
		A가 가지는 직접적인 의존성을 줄이기 위해 DI패턴이 필요하다.

*. ApplicationContext : 실제 스프링이 실행될 수 있게 공간을 마련해주는 클래스

		
	(1) IoC(Inversion of Control) 컨테이너
		:가지고 있던 주도권을 넘겨서 제어하는 방식. 스프링은 이런 방식을 가지고 있다.
		ex) 인스턴스를 내가 생성하다가 factory 에게 넘겼던 것.
	
	(2) DI를 구현하는 두가지 방법
		1) Constructor - based dependency injection
		2) Setter - based dependency injection
		


	(3) bean의 scope : 기본값은 싱글톤 
		(
			*bean 태그 내에 커서를 두고 ctrl+spacebar 하면 쓸 수있는 속성이 보인다.
			scope를 선택하고 또 scope 안에서 ctrl + spacebar 하면 4개의 쓸 수있는 속성이 나온다.
			request 는 웹에서 사용되는 것이며 응용 프로그램에서는 singleton과 prototype이 있다.
			singleton은 인스턴스를 한번 생성하며 prototype은 매번 생성하게 된다.		
		)
		
		- singleton
		- prototype
		
	(4) bean의 lifecycle (bean은 언제 생성되고 사용되는가?)
			아래의 다섯가지는 bean의 인터페이스에 관여한다.
			1) BeanNameAware
				void setBeanName(String name)
			
			2) BeanFactoryAware
				void setBeanFactory(BeanFactory beanFactory)
			3) InitializingBean
				void afterPropertiesSet()
			
			4) DisposableBean
				void	destroy()
				Invoked by a BeanFactory on destruction of a singleton.
			5) BeanPostProcessor
			
				Object	postProcessAfterInitialization(Object bean, String beanName)
				Apply this BeanPostProcessor to the given new bean instance after any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method).
				
				Object	postProcessBeforeInitialization(Object bean, String beanName)
				Apply this BeanPostProcessor to the given new bean instance before any bean initialization callbacks (like InitializingBean's afterPropertiesSet or a custom init-method).
		
			*note
				인터페이스를 구현(상속)하면 Override는 기본.
		
		
	(7) 지연초기화
		*note
		config.xml 의 bean이 만들어지는 시점은 언제인가?
			- ApplicationContext 가 생성될 때 bean도 생성된다.
			- 언제까지 늦추는가? getBean을 호출할 때, bean이 생성되도록 한다.
			- 설정파일에서 설정해줄 수 있다. bean 태그 내에서 ctrl + spacebar
				lazy-init="default" 이면 바로 생성, "true"면 getBean 호출할 때 생성
		
		
	**Log4J(System.out.println을 이용한 테스트가 아닌 로그를 이용한 테스트를 활용하자.)	
	
		(1) 구성 요소
			1) Logger : 출력할 메시지를 Appender에게 전달
			2) Appender : 전달받은 로그를 어디에 출력할지 결정
			3) Layout : 로그를 어떤 형식으로 출력할지 결정
			
		(2) 로그 레벨
			1) FATAL
			2) ERROR
			3) WARN
			4) INFO
			5) DEBUG
			6) TRACE
		
************************************************************************
	(8) Annotaion(spring에서 자주 사용되는 annotaion)
		1) @Component, @Controller, @Repository, @Service, @Configuration
		2) @Value
		3) **@Autowired** : *형식을 찾아서 원하는 형식이 있으면 자동으로 연결해주는 기능을 가진다.
				- required=false (형식에 맞는 값이나, 주소가 없을 때 에러처리하지 않고 try/catch처럼 넘어간다. 기본값은 true)
				- 필드 및 생성자, 메서드(일반, setter) 모두 사용가능
				- **스프링 전용으로 특화되어있으므로 Autowired가 최적화되어있다.
				
		4) @Qualifier : 이름으로 연결(Autowired가 2개 이상의 클래스가 있어서 장애를 일으킬 때 결정하도록 도와주는 annotation)
		5) @Inject, @Named -> 자바표준 annotation
			- JRS330에 정의(자바표준문법:자바의 어느곳에서든 사용가능)
			- @Inject = @Autowired ( autowired 대신 inject 사용가능)
			- @Named = @Component, @Qualifier ( component, qualifier 대신 named 사용 가능)
		6) @Resource('=. Autowired)
			- JSR250
			- 이름으로 연결 (autowired는 형식으로 연결)
			- 필드와 setter 에서 사용가능
			- **자바표준문법으로 자바와 스프링 모두 사용가능
	
		7) @Scope, @Lazy, @DependsOn, ...
		
			ex)
				//컴포넌트로 설정하면 기본적으로 싱글톤
				//하지만 @Scope를 사용하여 value를 설정하면 인스턴스 생성을 계속해서 할 수 있다.
				@Component
				@Scope(value="configurableBeanFactory.SCOPE_PROTOTYPE")
				public class Aclass{
						...		
				}
				
				-----------------------------------------------------------------------------------
				//지연초기화도 아래와 같이 사용가능
				@Lazy(value=true)
				@Component
				public class Aclass{
						...
				}
				-----------------------------------------------------------------------------------
				//의존에 관한 설정, 아래는 "beanA 와 beanB가 생성되고 Aclass를 생성되도록 하겠다" 라는 의미
				@DependsOn(value={"beanA", "beanB"})
				@Component
				public class Aclass{
						...
				}
	
	(9) SpEL(Spring EL)
		
		#{식} = #{객체.속성}
				
	(10) Validator 인터페이스를 이용한 객체의 유효성 검사
		(유효성 검사는 모듈화 시켜서 하는데 스프링은 잘 지원해주고있다.)
		- JSR303 어노테이션 https://mvnrepository.com/artifact/javax.validation/validation-api/1.1.0.Final
	
	(11) @Configuration, @Bean
			xml로 표현하지 않고 클래스로 표현하려는 움직임에 대한 annotation
			이 annotation을 사용하면 자바문법을 그대로 사용할 수 있다.
				
------------------------------------------------------------------------------------------------------------------------------------------------				
9. AOP(Aspect Orirented Programming)패턴 : 관점을 지향하는 방식, 공통 관심사 -> 객체지향(OOP)을 지원하기 위해 등장(보완하기 위함)
	: 단순히 분리시키는 것은 AOP가 아니다. AOP 컨테이너 내에 모듈을 가지고 있다가 필요한 위치에 자동으로 삽입되서 사용되도록 하는 것.
-----------------------------------------------------------------------------------------------------------------------
	- OOP(Object Oriented Programming)
	
		ex) 은행업무(객체지향: 모듈화를 하고 유기적으로 돌아가게하여 하나의 덩어리처럼 만들기)
		
		예금업무		여신업무		대출업무		보험업무
				
		---------------------업무들의 공통 관심사----------------------
		로깅	예외	트랜잭션(데이터의 안전성보장)	보안		
		---------------------------------------------------------------		
		**객체지향에서는 위처럼 공통되는 모듈을 반대하므로 이를 분리하는데, 이점이 객체지향이 가지는 단점이며 한계다.
			- 로깅이나 예외 등 공통 관심사에 대해서 필요한 업무에 자동적으로 삽입되면 좋겠는데 객체지향은 이점에 대해 한계를 가진다.
			- 이를 보완하기 위해서 AOP가 등장했다.
			- 업무들의 공통 관심사의 모습을 보고 '횡단 관심사' 라고도 표현한다.
	
	(1) 특징
		기능을 핵심 비지니스 로직과 공통 모듈을 구분하고, 핵심 로직에 영향을 미치지 않고 사이 사이에 공통 모듈을 효과적으로
		잘 끼워넣도록 하는 개발 방법
				
	(2) 구현 방법
				
			1) 컴파일 시점의 코드에 공통 기능을 추가하는 방법
			2) 클래스 로딩 시점의 바이트 코드에 추가하는 방법
			3) 런타임에 프록시 객체를 생성해서 추가하는 방법 - 스프링이 지원하는 방식
			
	(3) 구성 요소
		1) JoinPoint	: 공통 관심사가 들어갈 자리
							- Advice 적용 가능한 지점을 의미. 메서드 호출, 필드값 변경 등이 Joinpoint에 해당한다.
							
		2) Pointcut		: 여러개의 JoinPoint를 묶어서 나누는 것.(JoinPoint로만 관리하는 것은 너무 세분화되었기 때문)
							- Joinpoint의 부분집합으로 실제로 Advice가 적용되는 joinpoint를 나타낸다.
							
		3) Advice		: 어느 시점에 공통관심사 코드를 끼워넣을 것인가를 결정하는 것(시점을 정하는 것)
							- 언제 공통 관심 기능을 핵심 로직에 적용할지를 정의
								Before Advice			: 핵심 로직이 실행되기 전에
								After Returning Advice	: 핵심 로직이 실행된 후에 예외가 없으면
								After Throwing Advice	: 핵심 로직이 끝난 다음에 예외가 발생하면
								After Advice			: 예외와 상관없이 핵심 로직이 끝나면
								Around Advice			: 핵심 로직이 실행되기 전과 후, 두번 끼워넣음
			
			**Pointcut 과 Advice의 조화 : pointcut의 위치와 advice의 시점의 조화
			
		4) Weaving		: 실제 공통 관심사 코드가 위치하는, 끼워넣어지는 과정을 의미
							-Advice를 핵심로직에 적용하는 것
							
		5) Target		: 핵심 기능을 가지고 있는 클래스 즉, joinpoint들이 있는 곳
							- 핵심로직을 구현한 클래스
							
		6) Advisor		: 스프링에서만 사용됨. 표준AOP에는 없음.
							- Pointcut + Advice
							

	(4) 실습		
			1) Spring이나 AspectJ가 아닌 순수한 자바코드 - AOP가 필요한 동기부여
			2) 스프링 이용한 방식(스프링에서 제공하는 기능의 AOP - 제한적임)
				*인터페이스
					MethodBeforeAdvice		: 로직이 실행되기 전에 끼워넣을 수 있음
					AfterReturningAdvice	: 로직 실행 후 예외없으면 끼워넣음
					ThrowsAdvice			: 로직 실행 후 예외있으면 끼워넣음
					MethodInterceptor		: 로직 실행 전과 후에 두 번 끼워넣음
			3) POJO 이용한 방식(AspectJ 에서 제공하는 기능의 AOP)
				ProceedingJoinPoint
				org.aspectj.aspectwaver
			4) Annotation
				@Aspect, @Around, ...
				org.aspectj.aspectwaver
				
<특강>
스프링 홈페이지 참고 
http://docs.spring.io/spring-security/site/docs/4.1.1.RELEASE/reference/htmlsingle/

				
Acegi(='13579 보안모듈' 이라고 부름)

식별(Identification), 인증(Authentication), 권한(Authorization)
아이디 - Principle
패스워드 - Credential

시큐어 코딩

create table authorities(
	userid varchar(50) not null,
	authority varchar(50) not null,
	constraint fk_authorities foreign key(userid)
	references tbl_member(userid)
);			
