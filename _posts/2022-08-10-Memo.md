---
layout: post
date: 2022-08-10 23:43:00 +0900
title: 'Memo: 정리할 것들'
category:
  - writing
tags:
  - todo
  - memo
img: memo.png # Add image post (optional)
---

* Kramdown table of contents
{:toc .toc}

# View Template
## CSRdf

## SSR
### Thymeleaf(view) - todo
* Thymeleaf 시작하기  

html 태그에 다음과 같은 url을 입력하여 `th` 명령어를 활성화하도록 하자~
```html
<!DOCTYPE html>
<html xmlns:th="http://www.thymeleaf.org">
<head>
...
``` 

> `<p th:text="${model}">word</p>`

model에 `data` key-value로 담아 타임리프 뷰 템플릿이 렌더링될 때
아래 태그는 `empty`를 `data`에 바인딩된 값 `something`로 치환한다.

```html
...
<body>
<p th:text="${data}">empty</p>
</body>
</html>

결과 : <p>something</p>
```

* SpringEL 표현식

```thymeleaf
Object
${user.username} = userA
${user['username']} = userA
${user.getUsername()} = userA

List
${users[0].username} = userA
${users[0]['username']} = userA
${users[0].getUsername()} = userA

Map
${userMap['userA'].username} = userA
${userMap['userA']['username']} = userA
${userMap['userA'].getUsername()} = userA
```
***

# Programming Language
## Java
### AtomicLong(java) - todo
> 멀티쓰레드 환경에서 동시에 다수가 접근할 경우 데이터의 정합성을 보장할 수 없다.  
그래서 위와 같은 상황에 long 타입을 사용해야 한다면 `AtomicLong` 을 고려하라고~ 정리할 것

### ConcurrentHashMap(java) - todo
> AtomicLong 과 같은 이유임. 정리하셈

### Inner Class (Java) - todo

***

# FrameWork
## Spring
### log
* slf4j, logback
  + SLF4J - http://www.slf4j.org
  + Logback - http://logback.qos.ch
* [스프링 부트가 제공하는 로그 기능](https://docs.spring.io/spring-boot/docs/current/reference/html/spring-boot-features.html#boot-features-logging)
 
### BindingResult
> 스프링이 제공하는 검증 오류를 보관하는 객체이다. 검증 오류가 발생하면 여기에 보관하면 된다. BindingResult 가 있으면  @ModelAttribute 에 데이터 바인딩 시 오류가 발생해도 컨트롤러가 
호출된다!  

* 예) @ModelAttribute에 바인딩 시 타입 오류가 발생하면?  
  + BindingResult 가 없으면  400 오류가 발생하면서 컨트롤러가 호출되지 않고, 오류 페이지로 
이동한다.  
  + BindingResult 가 있으면  오류 정보( FieldError )를  BindingResult 에 담아서 컨트롤러를 
정상 호출한다.

* BindingResult에 검증 오류를 적용하는 3가지 방법
  + @ModelAttribute 의 객체에 타입 오류 등으로 바인딩이 실패하는 경우 스프링이  FieldError  생성해서 BindingResult 에 넣어준다.
  + 개발자가 직접 넣어준다.
  + Validator  사용  이것은 뒤에서 설명
* 타입 오류 확인  
숫자가 입력되어야 할 곳에 문자를 입력해서 타입을 다르게 해서  BindingResult 를 호출하고 
bindingResult 의 값을 확인해보자.
* 주의
  + BindingResult 는 검증할 대상 바로 다음에 와야한다. 순서가 중요하다. 예를 들어서 @ModelAttribute Item item , 바로 다음에  BindingResult 가 와야 한다.
  + BindingResult 는 Model에 자동으로 포함된다.

### Test Stub
> 꽁초,그루터기 등 마치 잔여물 같은 느낌의 단어를 연상캐한다. 
> 나름의 해석을 하자면 협업 간 필요 구현체가 미구현된 경우,
> 더미 객체를 활용하여 현재 구현부의 테스트를 진행할 수 있도록 해주는 것.
* Mockito 의 Stub Method
  + doReturn()
  + doNothing()
  + doThrow()

### 웹 프로젝트(spring) - todo
* 프로젝트 생성
  + project : gradle
  + Language : java
  + spring boot : 2.7
  + meta data
    - group : xxx
    - artifact : yyy
    - name : yyy
    - package name : group.artifact(=name) *기호제외
    - packaging : Jar
    - java : 11
  + dependencies
    - spring web
    - thymeleaf
    - lombok
* 요구사항 분석
  + 단위 테스트 규모의 프로젝트
  + 상품을 관리하는 서비스 개발
* 상품 도메인 모델
  + 상품ID
  + 상품명
  + 가격
  + 수량
* 상품 관리 기능
  + 상품 목록
  + 상품 상세
  + 상품 등록
  + 상품 수정
- 관련 퍼블리싱 html 전달받음
  + resources/static/html/sth.html
  + static html -> dynamic html
    - view template
    - resources/templates/basic/thymeleaf-sth.html 작업

### spring message (spring) - todo

### request and response data type setting (spring) - todo
> 요청에 의해 소모(consumes)해야 하는 데이터의 타입을 강제할 수 있다.  
```java
// 아래와 같이 json 타입을 강제하면 uri를 호출하는 요청자는 헤더의 데이터 타입을 명시해야한다.
// Content-Type : application/json
@PostMapping(value="/test", consumes = MediaType.APPLICATION_JSON_VALUE)
public void test(@RequestBody Something something){
  // ...
}
```
> 요청에 의한 반환할 생성(produces) 데이터를 정의하는 경우
```java
// 요청자는 반환되는 데이터의 타입을 헤더에 정의하여 요청할 수 있다. 
// Accept:application/json
@ResponseBody
@PostMapping(value="/test", produces = MediaType.APPLICATION_JSON_VALUE)
public void test(@RequestBody Something something){
  // ...
}
```
## Annotation
### Spring Annotation(spring) - todo
* @ModelAttribute
  + 해당 어노테이션을 선언하면 데이터 객체의 값을 Model 객체에 자동으로 담아준다.
* @RequestParam
  + HttpServletRequest 로 가져오던 parameter 정보를 @RequestParam variableName 으로 가져올 수 있음
* @RequestBody
  + 위의 어노테이션들과 달리 json 데이터인 경우 반드시 명시해야 함. 생략할 수 없음.

### Lombok Annotaion(spring) - todo
* @Getter/Setter
  + 프로퍼티를 필드에 선언하면 접근자/설정자(getOOO/setOOO)를 자동생성 해준다. (*boolean 의 경우 isOOO 형식임*)
* @ToString
  + toString 메서드를 자동생성해줌. 제외해야할 필드가 있다면 exclude에 명시해주면 된다.  
  ```@ToString(exclude = "password")```
* @EqualsAndHashCode  
  + 자바 빈을 만들 때 equals와 hashCode 메소드를 자주 오버라이딩 하는데  
  `@EqualsAndHashCode` 어노테이션을 사용하면 자동생성
  ```java
  /*
    callSuper 속성을 통해 equals와 hashCode 메소드 자동 생성 시 부모 클래스의 필드까지 감안할지 안 할지에 대해서 설정할 수 있습니다.
    즉, callSuper = true로 설정하면 부모 클래스 필드 값들도 동일한지 체크하며, 
    callSuper = false로 설정(기본값)하면 자신 클래스의 필드 값들만 고려합니다.
  */
  //domain layer
  @EqualsAndHashCode(callSuper = true)
    public class User extends Domain {
    private String username;
    private String password;
  }
  //service layer
  User user1 = new User();
  user1.setId(1L);
  user1.setUsername("user");
  user1.setPassword("pass");

  User user2 = new User();
  user1.setId(2L); // 부모 클래스의 필드가 다름
  user2.setUsername("user");
  user2.setPassword("pass");

  user1.equals(user2);
  // callSuper = true 이면 false, callSuper = false 이면 true
  ```
* @NoArgsConstructor
  + 파라미터가 없는 기본 생성자를 생성
* @AllArgsConstructor
  + 모든 필드값을 파라미터로 받는 생성자를 생성
* @RequiredArgsContructor
  + 이녀석은 `final` 또는 `@NonNull` 필드만을 대상으로 생성자를 생성함. 객체의 의존성 주입을 생성자를 따로 작성하지 않아도 자동주입해줌
* @Data
  + `@Data`는 위의 `@Getter, @Setter, @RequiredArgsConstructor, @ToString, @EqualsAndHashCode`을 한꺼번에 설정해주는 매우 유용한 어노테이션
### Jackson Annotaition - todo
* @JsonInclude
  > json 형식으로 데이터를 주고받을 때 Jackson의 ObjectMapper를 자주 이용한다.  
  그런데 기본값으로 Serialize 하게 되면 null, "" 같은 (상황에 따라) 필요 없는 값 또한 모두 변환시켜준다.  
  이를 아래의 메소드를 통하여 Serialize할 때 원하는 값만을 포함시킬 수 있다.
  ```java
  @Getter
  //@JsonInclude(JsonInclude.Include.원하는타입)
  public static class Value {
      private String string;
      private String emptyString;
      private Object nullValue;
      private int number;
      private int zero;
      private List<String> list;
      private List<String> emptyList;
      private Date date;
      private Date zeroDate;
      private Optional<String> optional;
      private Optional<String> emptyOptional;


      public Value() {
          this.string = "민수";
          this.emptyString = "";
          this.nullValue = null;
          this.number = 100;
          this.zero = 0;
          this.list = asList("민수", "원우");
          this.emptyList = emptyList();
          date = new Date();
          zeroDate = new Date(0L);
          this.optional = Optional.of("민수");
          this.emptyOptional = Optional.empty();
      }
  }
  ```

  + ALWAYS (기본값) : 모든 값을 출력
  ```java
  @Test
  public void always() throws JsonProcessingException {
      this.objectMapper.setSerializationInclusion(JsonInclude.Include.ALWAYS);
      String result = this.objectMapper.writeValueAsString(new Value());

      System.out.println(result);
  }
  //결과
  {
    "string": "민수",
    "emptyString": "",
    "nullValue": null,
    "number": 100,
    "zero": 0,
    "list": [
      "민수",
      "원우"
    ],
    "emptyList": [],
    "date": 1527077763796,
    "zeroDate": 0,
    "optional": {
      "present": true
    },
    "emptyOptional": {
      "present": false
    }
  }
  ```

  + NON_NULL : null은 제외한다.
  ```java
  @Test
  public void non_null() throws JsonProcessingException {
      this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
      String result = this.objectMapper.writeValueAsString(new Value());

      System.out.println(result);
  }
  //결과
  {
    "string": "민수",
    "emptyString": "",
    "number": 100,
    "zero": 0,
    "list": [
      "민수",
      "원우"
    ],
    "emptyList": [
    ],
    "date": 1527077763837,
    "zeroDate": 0,
    "optional": {
      "present": true
    },
    "emptyOptional": {
      "present": false
    }
  }
  ```

  + NON_ABSENT : null 제외, 참조 유형('Optional' 또는 {link java.utl.concurrent.atomic.AtomicReference})의   
  `absent`값; 즉, null이 아닌 값은 제외한다. 
  ```java
  @Test
  public void non_absent() throws JsonProcessingException {
      this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_ABSENT);
      String result = this.objectMapper.writeValueAsString(new Value());

      System.out.println(result);
  }
  //결과
  {
    "string": "민수",
    "emptyString": "",
    "number": 100,
    "zero": 0,
    "list": [
      "민수",
      "원우"
    ],
    "emptyList": [
    ],
    "date": 1527077763833,
    "zeroDate": 0,
    "optional": {
      "present": true
    },
    "emptyOptional": {
      "present": false
    }
  }
  ```
+ NON_EMPTY : 
> null은 제외한다.  
  absent는 제외한다. ( 3. NON_ABSENT 참고 )  
  Collection, Map의 isEmpty()가 true 이면 제외한다.  
  Array의 length가 0이면 제외한다.  
  String의 length()가 0이면 제외한다.  

```java 
@Test
public void non_empty() throws JsonProcessingException {
    this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_EMPTY);
    String result = this.objectMapper.writeValueAsString(new Value());

    System.out.println(result);
}
//결과
{
  "string": "민수",
  "number": 100,  
  "zero": 0,
  "list": [
    "민수",
    "원우"
  ],
  "date": 1527077763822,
  "zeroDate": 0,
  "optional": {
    "present": true
  },
  "emptyOptional": {
    "present": false
  }
}
```  
+ NON_DEFAULT : 
> empty는 제외된다. ( 4. NON_EMPTY 참고 )  
  primitive 타입이 디폴트 값이면 제외한다. (int / Integer : 0 , boolean / Boolean : false 등)  
  Date의 timestamp가 0L이면 제외한다.  

```java
@Test
public void non_default() throws JsonProcessingException {
    this.objectMapper.setSerializationInclusion(JsonInclude.Include.NON_DEFAULT);
    String result = this.objectMapper.writeValueAsString(new Value());

    System.out.println(result);
}
//결과
{
  "string": "민수",
  "number": 100,
  "list": [
    "민수",
    "원우"
  ],
  "date": 1527077763725,
  "optional": {
    "present": true
  },
  "emptyOptional": {
  }
}
```
***

# Javascript
## mocha unit framework
## SpringEL
* 참고: [SpringEL](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#expressions-operator-safe-navigation)
### ?. (=Safe Navigation Operator)
스프링의 SpringEL이 제공하는 문법 중 하나.
만약 여기에서 errors 가 null 이라면 어떻게 될까?
최초 등록폼에 진입한 시점에는 validation에 의한 errors가 없다.
따라서 errors.containsKey() 를 호출하는 순간 NullPointerException 이 발생한다.
(`errors?.` 에서 `?` 를 떼면 `null.` 처럼 표현할 수 있기 때문에 NPE 발생. 치명적이돠)
errors?. 은 errors 가 null 일때 NullPointerException 이 발생하는 대신, null 을 반환하는 문법이다.
th:if 에서 null 은 실패로 처리되므로 오류 메시지가 출력되지 않는다.
```html
  <div th:if="${errors?.containsKey('globalError')}">
      <p class="field-error" th:text="${errors['globalError']}">전체 오류 메시지</p>
  </div>
```

### Json
* JSON.stringify(data)

***
# Tool
## software
### 맥북 스포트라이트 점유율문제(Tool) - end
> 않이, 어제 갑자기 쿨링팬이 돌길래 활성모니터로 상태를 봤더니 점유율이 굉장히 높은 녀석이 있는게 아니겠음?

확인해 보니 스포트라이트 관련된 녀석인데 돌지 말라고 꺼버림! 

    sudo mdutil -a -i off

그러면 스포트라이트 안쓰냐고? 그래서 알프레드 쓰기로 함^.^

### 인텔리제이 properties 한글깨짐현상 (tool) - todo
> 인텔리제이를 사용하다 보면 한글깨짐이 생기는 현상이 있다. 요것을 해결하는 방법
* properties 파일 내 한글깨짐현상
  - prefernce -> File Encodings -> properties files : UTF-8, Transparent native-to-ascii conversion 체크

### 맥 기본 설정 (Tool) - todo
> 내 입맛에 맞춘 나의 방식이야🤣

* 터치패드
  - 터치패드 - 세 손가락 드래그
  - 터치패드 - 탭하여 클릭
* 키보드
  - 키보드 입력, 지연 딜레이 최소화
  - 키보드 - 입력소스 - 두벌식(한글) - 삭제방식 : 글자
  - 키보드 - 텍스트 - 우측 체크박스 해제
* 툴 

***

## DB
### mariaDB (DB) - todo
* WITH RECURSIVE 문 (todo : with 과 비교해서 작성)
  + 메모리 상에 가상의 테이블을 저장
  + 재귀 쿼리를 이용, 실제 테이블을 생성 또는 데이터 Insert 없이 가상 테이블 생성가능
  ```mysql
  //설명
  WITH RECURSIVE 테이블명 AS(
    SELECT 초기값 AS 컬럼별명
    UNION ALL
    SELECT 컬럼별명 계산식 FROM 테이블명 WHERE 제어문
  )
  //예시 : h(컬럼) 초기값 1부터 제어문에 합당하는 5까지의 데이터를 갖는 가상테이블 생성
  WITH RECURSIVE CTE AS(
    SELECT 1 AS h
    UNION ALL
    SELECT h+1 FROM CTE WHERE <5
  )
  SELECT * FROM CTE;
  ```
* IFNULL
  + IFNULL(exp1, exp2)
    - 순차적 체크
    - exp1가 null이 아니면 exp1 반환
    ```mysql
    mysql> SELECT IFNULL(1,0);
        -> 1
    mysql> SELECT IFNULL(NULL,10);
        -> 10
    mysql> SELECT IFNULL(1/0,10);
        -> 10
    mysql> SELECT IFNULL(1/0,'yes');
        -> 'yes'
    ```
***

### Documents (doc) - todo
> 공식 문서들 정리
* 타임리프
  + [타입리프 공식 사이트](https://www.thymeleaf.org/)
  + [타입리프 공식 메뉴얼 - 기본 기능](https://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html)
  + [타입리프 공식 메뉴얼 - 스프링 통합](https://www.thymeleaf.org/doc/tutorials/3.0/thymeleafspring.html)


### HTML Form (HTTP) - todo
> HTML Form 전송은 PUT, PATCH를 지원하지 않는다.  
GET, POST만 사용할 수 있음. 정리할 것.

### PRG[POST/Redirect/GET] (HTTP) - todo

### TLD:Tag Library Description (Servlet/JSP) - todo

***

# etc
## package
### 구조&설계
* hello.login
  + domain
    - item
    - member
    - login
  + web
    - item
    - member
    - login

> 핵심 업무 도메인은 처리되는 비즈니스 영역  
웹은 도메인에 의존하도록, 반대로 도메인은 웹을 의존하지 않도록 한다.  
웹의 영역이 사라져도 도메인의 코드의 최대한 컴파일 에러가 없도록 유지해야 한다.